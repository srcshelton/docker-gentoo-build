#! /bin/sh
# shellcheck disable=SC2030,SC2031

# entrypoint.sh.build

set -eu

# shellcheck disable=SC2034
debug=${DEBUG:-}
# shellcheck disable=SC2034
trace=${TRACE:-}

DEFAULT_JOBS="${DEFAULT_JOBS:-"__JOBS__"}"
DEFAULT_MAXLOAD="${DEFAULT_MAXLOAD:-"__MAXLOAD__"}"
environment_file="${environment_file:-"__ENVFILE__"}"

die() {
	printf >&2 'FATAL: %s\n' "${*:-"Unknown error"}"
	exit 1
}  # die

warn() {
	[ -z "${*:-}" ] && echo || printf >&2 'WARN:  %s\n' "${*}"
}  # warn

info() {
	[ -z "${*:-}" ] && echo || printf 'INFO:  %s\n' "${*}"
}  # info

print() {
	if [ -n "${DEBUG:-}" ]; then
		if [ -z "${*:-}" ]; then
			echo >&2
		else
			printf >&2 'DEBUG: %s\n' "${*}"
		fi
	fi
}  # print

format() {
	format_spaces='' format_string=''

	# Pad $format_variable to $format_padding trailing spaces
	#
	format_variable="${1:-}"
	format_padding="${2:-"20"}"

	[ -n "${format_variable:-}" ] || return 1

	format_variable="$( # <- Syntax
		echo "${format_variable}" | xargs -rn 1 | sort -d | xargs -r
	)"
	format_spaces="$( printf "%${format_padding}s" )"
	format_string="%-${format_padding}s= \"%s\"\\n"

	# shellcheck disable=SC2059
	printf "${format_string}" "${format_variable}" "$( # <- Syntax
		cat - |
			grep -- "^${format_variable}=" |
			cut -d'"' -f 2 |
			fmt -w $(( ${COLUMNS:-"80"} - ( format_padding + 3 ) )) |
			sed "s/^/   ${format_spaces}/ ; 1 s/^\s\+//"
	)"

	unset format_string format_spaces format_padding format_variable

	return 0
}  # format

parse_opt() {
	#inherit ROOT
	po_opt="${1:-}"
	po_next="${2:-}"
	po_line='' po_arg='' po_matched=0

	[ -n "${po_opt:-}" ] || return 1

	print "parse_opt: Called with parameters '${po_opt}', '${po_next}'"

	# The only way to get emerge to show most(*) valid options is to give it an
	# intentionally unrecognised argument :o
	#
	# (*) It seems that short-options such as '-k' for '--usepkg=y' aren't
	# listed even then...
	#
	po_var="po_emerge_$( echo "${ROOT:-"/root"}" | cut -d'/' -f 2 )_opts"
	if [ -z "$( eval "echo \${${po_var}:-}" )" ]; then
		print "parse_opt: Generating new emerge option list for root '${ROOT:-}'"
		eval "${po_var}=\$(
			emerge --bad_option 2>&1 |
				grep -v -- '^emerge: error: unrecognized arguments: --bad_option$' |
				sed 's/^[^[]*\[/[/ ; s/^\[// ; s/\] \[/!/g ; s/\]$//' |
				tr '!' '\n' |
				grep -v -- '^positional_args' |
				tr '\n' '!'
		)"
	fi
	[ -n "$( eval "echo \${${po_var}:-}" )" ] || return 1

	while read -r po_line; do
		[ $(( po_matched )) -eq 1 ] && break
		case "${po_line}" in
			"${po_opt%"="*}")
				# The emerge option we've just read matches our argument fully,
				# so it is a stand-alone option...
				#
				print "parse_opt: Matched option '${po_opt%"="*}' to line '${po_line}' with 'option_ok'"
				echo 'option_ok'
				po_matched=1
				break
				;;
			"${po_opt%"="*} "*)
				# The emerge option we've just read matches the start of our
				# argument but the option has further parameters, so we need to
				# do more checks...
				#
				if echo "${po_opt}" | grep -Fq -- '='; then
					po_arg="${po_opt#*"="}"
				else
					po_arg="${po_next:-}"
				fi
				print "parse_opt: Matched option '${po_opt%"="*}' with argument '${po_arg}' to line '${po_line}' ..."
				case "${po_line}" in
					"${po_opt%"="*} {"*)
						# We have a list of valid options such as
						# '--ask {True,y,n}'
						#
						print "           ... valid competions are '${po_line#* }'"
						if echo "${po_arg}" | grep -Eq -- "$( # <- Syntax
								echo "${po_line}" |
									awk '{ print $2 }' |
									grep -o -- '{[^}]\+}' |
									sed 's/^{// ; s/}$// ; s/,/|/g' )"
						then
							if [ "${po_opt}" = "${po_opt%"="*}=${po_arg}" ]
							then
								print "           Matched single-argument valid completion in '${po_arg}' - returning option_single_arg_ok"
								echo 'option_single_arg_ok'
							else
								print "           Matched valid completion in '${po_arg}' - returning option_arg_ok"
								echo 'option_arg_ok'
							fi
						else
							if [ "${po_opt}" = "${po_opt%"="*}=${po_arg}" ]
							then
								print "           No matching single-argument completion in '${po_arg}' - returning option_single_arg_bad"
								echo 'option_single_arg_bad'
							else
								print "           No matching completion in '${po_arg}' - returning option_arg_bad"
								echo 'option_arg_bad'
							fi
						fi
						po_matched=1
						break
						;;
					*)
						# We can't further validate options to arguments such
						# as '--root ROOT'
						#
						print "parse_opt: Matched option '${po_opt%"="*}' with unchecked argument to line '${po_line}' - returning option_arg"
						echo 'option_arg'
						po_matched=1
						break
						;;
				esac
				;;
			#*)
			#	# The emerge option we're just read doesn't match our argument
			#	# at all
			#	#
			#	:
			#	;;
		esac
	done <<-EOI
		$( eval "echo \${${po_var}:-}" | tr '!' '\n' )
	EOI
	if [ $(( po_matched )) -eq 0 ]; then
		print "parse_opt: No matching option - returning 'option_bad'"
		echo 'option_bad'
	fi

	unset po_matched po_arg po_line po_next po_opt
}  # parse_opt

parse_opt_get() {
	pog_mode='' pog_arg='' pog_next_arg='' pog_first='' pog_done=0

	if [ -n "${1:-}" ] && [ -n "${2:-}" ]; then
		pog_mode="${1}"
		shift
	else
		return 1
	fi
	case "${pog_mode}" in
		'opt')  : ;;
		'pkg')  : ;;
		'pkgs') : ;;
		*)
			error "parse_opt_get: invalid mode '${pog_mode}'"
			return 1
			;;
	esac

	while [ -n "${1:-}" ] && [ $(( pog_done )) -eq 0 ]; do
		print "parse_get_opt: Looping with ${#} parameters, first is '${1}', second is '${2:-}' (done: ${pog_done})"
		pog_arg="${1}"
		pog_next_arg="${2:-}"
		case "${pog_arg}" in
			-*)
				# We'll naively assume that anything starting with a hyphen is
				# a valid option...
				#
				pog_result="$( parse_opt "${pog_arg}" "${pog_next_arg:-}" )"
				case "${pog_result:-}" in
					'option_ok'|'option_single_arg_ok')
						# Recognised option with no parameter
						#
						unset pog_next_arg
						if [ -n "${2:-}" ]; then
							shift
						else
							pog_done=1
						fi
						;;
					'option_bad'|'option_single_arg_bad')
						# Some options, such as '-k' for '--usepkg', aren't
						# declared by emerge, so we'll warn and continue as if
						# the option has no parameter
						#
						[ "${pog_mode}" = 'opt' ] &&
							warn "emerge option '${pog_arg}' may be invalid"
						unset pog_next_arg
						if [ -n "${2:-}" ]; then
							shift
						else
							pog_done=1
						fi
						;;
					'option_arg_ok'|'option_arg')
						# We have a declared option followed by a recognised
						# parameter
						#
						if [ -n "${3:-}" ]; then
							shift 2
						else
							pog_done=1
						fi
						;;
					'option_arg_bad')
						# We might have a declared option followed by an
						# invalid parameter, although for some options the
						# parameter is optional - we have to assume this is the
						# case
						#
						[ "${pog_mode}" = 'opt' ] &&
							warn "emerge parameter '${pog_next_arg:-}' may" \
								"be invalid for option '${pog_arg}'"
						if [ -n "${2:-}" ]; then
							shift
						else
							pog_done=1
						fi
						;;
					*)
						die "parse_get_opt: Unknown parse_opt() result '${pog_result}'"
						;;
				esac
				if [ "${pog_mode}" = 'opt' ]; then
					printf '%s%s%s' \
						"${pog_first}" \
						"${pog_arg}" \
						"${pog_next_arg:+" ${pog_next_arg}"}"
					pog_first=' '
				fi
				;;

			*)
				print "parse_opt_get: Assuming that parameter '${pog_arg}' is a package ..."
				case "${pog_mode}" in
					'opt')
						shift
						;;
					'pkg')
						echo "${pog_arg}"
						break
						;;
					'pkgs')
						printf '%s%s' \
							"${pog_first}" \
							"${pog_arg}"
						pog_first=' '
						shift
						;;
				esac
				;;
		esac
	done
	[ "${pog_first:-}" = ' ' ] && printf '\n'

	unset pog_arg pog_last_arg
}  # parse_opt_get

parse_opt_get_options() {
	parse_opt_get 'opt' "${@:-}" | xargs -r
}  # parse_opt_get_options

parse_opt_get_package() {
	parse_opt_get 'pkg' "${@:-}"
}  # parse_opt_get_package

parse_opt_get_packages() {
	parse_opt_get 'pkgs' "${@:-}" | xargs -r
}  # parse_opt_get_packages

check() {
	#inherit ROOT
	check_rc="${1:-}" ; shift

	# Check that a given check_pkg (with build result code $check_rc) is
	# actually installed...
	#
	[ -n "${check_rc:-}" ] || return 1

	check_pkg='' check_arg=''

	if [ $(( check_rc )) -eq 0 ]; then
		# Process first package of list only...
		#
		for check_arg in "${@}"; do
			case "${check_arg}" in
				-*)	continue ;;
				*)	check_pkg="${check_arg}" ; break ;;
			esac
		done
		check_pkg="$( echo "${check_pkg}" | sed -r 's/^[^a-z]+([a-z])/\1/' )"
		if echo "${check_pkg}" | grep -Fq -- '/'; then
			if ! ls -1d \
					"${ROOT:-}/var/db/pkg/${check_pkg%"::"*}"* >/dev/null 2>&1
			then
				die "emerge indicated success but package" \
					"'${check_pkg%"::"*}' does not appear to be installed"
			fi
		else
			if ! ls -1d \
					"${ROOT:-}/var/db/pkg"/*/"${check_pkg%"::"*}"* >/dev/null 2>&1
			then
				die "emerge indicated success but package" \
					"'${check_pkg%"::"*}' does not appear to be installed"
			fi
		fi
	fi

	unset check_pkg check_arg

	# shellcheck disable=SC2086
	return ${check_rc}
}  # check

checkmissing() {
	#inherit ROOT
	cm_arg='' cm_package='' cm_path=''

	# Check that packages passed in as arguments have been removed
	#
	# Process first package of list only...
	#
	for cm_arg in "${@}"; do
		case "${cm_arg}" in
			-*)	continue ;;
			*)	cm_package="${cm_arg}" ; break ;;
		esac
	done
	cm_package="$( echo "${cm_package}" | sed -r 's/^[^a-z]+([a-z])/\1/' )"
	if echo "${cm_package}" | grep -Fq -- '/'; then
		cm_path="${ROOT:-}/var/db/pkg/${cm_package%"::"*}"
	else
		cm_path="${ROOT:-}/var/db/pkg/*/${cm_package%"::"*}"
	fi
	if echo "${cm_package}" | grep -Fq -- '/'; then
		if ls -1d ${cm_path}/* >/dev/null 2>&1; then
			warn "emerge indicated success but package '${cm_package%"::"*}'" \
				"still appears to be installed under root '${ROOT:-"/"}'"
			return 1
		fi
	fi

	unset cm_package cm_arg
	return 0
}  # checkmissing

pkg_remove() {
	#inherit ROOT
	pr_force=1 pr_verbose=''
	if [ "${1:-}" = '--no-force' ]; then
		pr_force=0
		shift
	fi
	if [ "${1:-}" = '--verbose' ]; then
		pr_verbose='v'
		shift
	fi
	pr_stage="${1:-}" ; shift
	pr_remove="${*:-}"
	pr_pkg='' pr_args=''

	(
		for ROOT in $( echo "${ROOT:-}" '/' | xargs -n 1 | sort | uniq ); do
			export ROOT="${ROOT:-"/"}"
			export LC_ALL='C'

			[ -d "${ROOT}" ] || continue

			# Exclude cases where everything in ${pr_remove} is an (hyphen-
			# prefixed) option...
			#
			if [ -n "${pr_remove:-}" ] &&
					echo "${pr_remove}" | grep -Eq -- '(^|\s)[a-z]'
			then
				echo
				echo " * Removing specified${pr_stage:+" ${pr_stage}"}" \
					"packages '${pr_remove}' from root '${ROOT}' ..."
			fi

			# shellcheck disable=SC2086
			LC_ALL='C' emerge \
					--ignore-default-opts \
					--color=y \
					--verbose=n \
					--verbose-conflicts \
					--with-bdeps=n \
					--with-bdeps-auto=n \
				--depclean ${pr_remove} || :

			if [ -n "${pr_remove:-}" ] &&
					echo "${pr_remove}" | grep -Eq -- '(^|\s)[a-z]'
			then
				# emerge --depclean exits with code zero even if removal
				# doesn't succeed :(
				#
				# N.B. checkmissing() only processes the first non-hyphenated
				#      argument...
				#      We'll assemble the argument list in sequence and only
				#      apply then once encountered.
				#
				for pr_pkg in ${pr_remove}; do
					case "${pr_pkg}" in
						-*)
							pr_args="${pr_args:+"${pr_args} "}${pr_pkg}"
							;;
						*)
							# shellcheck disable=SC2086
							checkmissing "${pr_pkg}" ||
								LC_ALL='C' emerge \
										--ignore-default-opts \
										--color=y \
										--verbose=n \
										--verbose-conflicts \
										--with-bdeps=n \
										--with-bdeps-auto=n \
									--rage-clean ${pr_args} -- "${pr_pkg}" || :
							;;
					esac
				done

				for pr_pkg in ${pr_remove}; do
					case "${pr_pkg}" in
						-*)
							:
							;;
						*)
							# shellcheck disable=SC2086
							checkmissing "${pr_pkg}" || exit ${?}
							;;
					esac
				done

				#LC_ALL='C' emerge --depclean -v

				for pr_pkg in ${pr_remove}; do
					case "${pr_pkg}" in
						-*)
							:
							;;
						*)
							rm -r${pr_verbose} \
									"${ROOT%"/"}/var/db/pkg/"*"/${pr_pkg}"* 2>/dev/null ||
								rm -r${pr_verbose} \
										"${ROOT%"/"}/var/db/pkg/${pr_pkg}"* 2>/dev/null || :

							if [ -e "${ROOT%"/"}/var/lib/portage/world" ]; then
								pr_str="$( echo "${pr_pkg}" | sed 's|/|\\/|g' )"
								if sed -i "/${pr_str}/ d" \
										"${ROOT%"/"}/var/lib/portage/world"
								then
									print "Manually removed '${pr_pkg}' from world profile"
								else
									warn "Failed to remove '${pr_pkg}' from world" \
										"profile (or package already removed)"
								fi
								unset pr_str
							fi
							;;
					esac
				done
				unset pr_pkg
			fi  # [ -n "${pr_remove:-}" ] && echo "${pr_remove}" | grep -Eq -- '(^|\s)[a-z]'
		done
	)

	unset pr_remove pr_stage
}  # pkg_remove

savefailed() {
	#inherit PORTAGE_LOGDIR PORTAGE_LOGDIR
	sf_rc=0

	# Save failed build logs ...
	# (e.g. /var/tmp/portage/app-misc/mime-types-9/temp/build.log)
	# (e.g. /var/tmp/portage/net-misc/dhcpcd-10.0.6-r2/work/dhcpcd-10.0.6/config.log)

	#[ -n "${trace:-}" ] || set -o xtrace

	# We can't rely on findutils being present...
	#
	# shellcheck disable=SC2012
	if [ -n "$( # <- Syntax
			ls -1 2>/dev/null \
					"${PORTAGE_TMPDIR}"/portage/*/*/temp/build.log \
					"${PORTAGE_TMPDIR}"/portage/*/*/work/*/config.log |
				head -n 1 || :
	)" ]; then
		mkdir -p "${PORTAGE_LOGDIR}"/failed
		for file in \
				"${PORTAGE_TMPDIR}"/portage/*/*/temp/build.log \
				"${PORTAGE_TMPDIR}"/portage/*/*/work/*/config.log
		do
			[ -e "${file}" ] || continue

			sf_rc=1
			type="$( echo "${file}" | rev | cut -d'/' -f 1 | rev )"
			case "${type}" in
				build.log)
					cat="$( echo "${file}" | rev | cut -d'/' -f 4 | rev )"
					pkg="$( echo "${file}" | rev | cut -d'/' -f 3 | rev )"
					;;
				config.log)
					cat="$( echo "${file}" | rev | cut -d'/' -f 5 | rev )"
					pkg="$( echo "${file}" | rev | cut -d'/' -f 4 | rev )"
					;;
				*)
					warn "Unknown log type '${type}'"
					continue
					;;
			esac
			mkdir --parents "${PORTAGE_LOGDIR}/failed/${cat}"
			mv --verbose "${file}" \
				"${PORTAGE_LOGDIR}/failed/${cat}/${pkg}-${type}" 2>/dev/null || :
			rmdir \
					--parents \
					--ignore-fail-on-non-empty \
				"$( dirname "${file}" )" "${PORTAGE_LOGDIR}/failed/${cat}" || :
			unset type pkg cat
		done
	fi

	#[ -n "${trace:-}" ] || set +o xtrace

	return ${sf_rc}
}  # savefailed

applyworkarounds() {
	#inherit use_essential_gcc USE post_pkgs
	aw_arg="${1:-}"
	aw_pkgs='' aw_list='' aw_pkg=''
	aw_USE='' aw_post_pkgs='' aw_post_use=''
	aw_mode=0

	# N.B. Ensure any status/user-information output goes to &2!
	#
	# modes:
	#  0 - Add required USE-flags
	#  1 - Add required post_pkgs
	#  2 - Add required post_use

	if echo "${aw_arg:-}" | grep -q -- '^--'; then
		# It's possible for the first argument to be an emerge(1) parameter,
		# so don't abort if we don't get a match below (although we don't need
		# to keep these parameters either).  Explicitly using '--use' also
		# fixes this...
		#
		if [ "${aw_arg:-}" = '--post_pkgs' ] ||
				[ "${aw_arg:-}" = '--post-pkgs' ]
		then
			aw_mode=1
		elif [ "${aw_arg:-}" = '--post_use' ] ||
				[ "${aw_arg:-}" = '--post-use' ]
		then
			aw_mode=2
		elif [ "${aw_arg:-}" = '--use' ]; then
			:
		else
			#return 1
			warn >&2 "Unexpected option parameter '${aw_arg:-}': recommend" \
				"calling 'applyworkarounds --use ...'"
		fi
		[ -n "${2:-}" ] || return 1
		shift
		aw_arg="${1}"
	fi
	[ -n "${aw_arg:-}" ] || return 1

	if [ $(( aw_mode )) -eq 0 ]; then
		if [ -n "${2:-}" ]; then
			shift
			if [ "${USE:-}" = "${*}" ]; then
				aw_USE="${USE}"
			else
				aw_USE="${USE:+"${USE} "}${*}"
			fi
		fi
	else
		if [ -n "${2:-}" ]; then
			warn >&2 "Additional arguments received to" \
				"applyworkarounds(<mode>, '${aw_arg}', >'${*}'<)"
		fi
	fi
	print >&2 "applyworkarounds() called for package(s) '${aw_arg}' with parameters '${*:-}'"

	#aw_pkgs='app-containers/buildah'
	#[ $(( aw_mode )) -ne 2 ] &&
	#	info >&2 "Checking for ${aw_pkgs} work-arounds ..."
	#aw_list=''
	#for aw_pkg in ${aw_pkgs}; do
	#	aw_list="${aw_list:+"${aw_list}|"}${aw_pkg#*"/"}|${aw_pkg}"
	#done
	#aw_pkg=''
	#if aw_pkg="$( # <- Syntax
	#		echo " ${aw_arg} " |
	#			sed 's/ /  /g' |
	#			grep -Eo -- " ([<>]?=|~)?(${aw_list})(-[^ ]+)? "
	#)" && [ -n "${aw_pkg:-}" ]
	#then
	#	if [ $(( aw_mode )) -eq 1 ]; then
	#		aw_pkg="$( echo "${aw_pkg}" | xargs -r )"
	#		warn >&2 "Adding post-package entry 'sys-devel/binutils'" \
	#			"due to presence of ${aw_pkg} ..."
	#		aw_post_pkgs="${aw_post_pkgs:+"${aw_post_pkgs} "}sys-devel/binutils"
	#	elif [ $(( aw_mode )) -eq 0 ]; then
	#		warn >&2 "Activating app-containers/buildah work-arounds ..."
	#		print >&2 "Before work-around, USE is '${aw_USE}' ..."
	#		aw_USE="${aw_USE:+"$( # <- Syntax
	#			echo " ${aw_USE} " | sed 's/ -gold / / ; s/^ //'
	#		)"}gold"
	#		print >&2 "After work-around, USE is '${aw_USE}'"
	#	fi
	#fi

	aw_pkgs='app-containers/podman app-containers/netavark app-containers/aardvark-dns virtual/rust dev-lang/rust dev-util/bindgen'
	[ $(( aw_mode )) -ne 2 ] &&
		info >&2 "Checking for ${aw_pkgs} work-arounds ..."
	aw_list=''
	for aw_pkg in ${aw_pkgs}; do
		aw_list="${aw_list:+"${aw_list}|"}${aw_pkg#*"/"}|${aw_pkg}"
	done
	aw_pkg=''
	#print >&2 "Matching ' ${aw_arg} ' against ' ([<>]?=|~)?(${aw_list})(-[^ ]+)? '"
	if aw_pkg="$( # <- Syntax
			echo " ${aw_arg} " |
				sed 's/ /  /g' |
				grep -E0 -- " ([<>]?=|~)?(${aw_list})(-[^ ]+)? "
		)" && [ -n "${aw_pkg:-}" ]
	then
		if [ $(( aw_mode )) -eq 1 ]; then
			aw_pkg="$( echo "${aw_pkg}" | xargs -r )"
			warn >&2 "Adding post-package entry 'net-misc/curl'" \
				"due to presence of ${aw_pkg} ..."
			aw_post_pkgs="${aw_post_pkgs:+"${aw_post_pkgs} "}net-misc/curl"
		elif [ $(( aw_mode )) -eq 0 ]; then
			warn >&2 "Activating app-containers/netavark work-arounds ..."
			print >&2 "Before work-around, USE is '${aw_USE}' ..."
			aw_USE="${aw_USE:+"$( # <- Syntax
				echo " ${aw_USE} " | sed 's/ -http2 / / ; s/ -rustfmt / / ; s/^ //'
			)"}http2 rustfmt"
			print >&2 "After work-around, USE is '${aw_USE}'"
		fi
	fi

	aw_pkgs='dev-lang/php media-libs/freetype media-libs/harfbuzz'
	[ $(( aw_mode )) -ne 2 ] &&
		info >&2 "Checking for ${aw_pkgs} work-arounds ..."
	aw_list=''
	for aw_pkg in ${aw_pkgs}; do
		aw_list="${aw_list:+"${aw_list}|"}${aw_pkg#*"/"}|${aw_pkg}"
	done
	aw_pkg=''
	#print >&2 "Matching ' ${aw_arg} ' against ' ([<>]?=|~)?(${aw_list})(-[^ ]+)? '"
	if aw_pkg="$( # <- Syntax
			echo " ${aw_arg} " |
				sed 's/ /  /g' |
				grep -Eo -- " ([<>]?=|~)?(${aw_list})(-[^ ]+)? "
		)" && [ -n "${aw_pkg:-}" ]
	then
		if [ $(( aw_mode )) -eq 1 ]; then
			aw_pkg="$( echo "${aw_pkg}" | xargs -r )"
			warn >&2 "Adding post-package entry 'media-libs/freetype'" \
				"due to presence of ${aw_pkg} ..."
			aw_post_pkgs="${aw_post_pkgs:+"${aw_post_pkgs} "}media-libs/freetype"
		elif [ $(( aw_mode )) -eq 0 ]; then
			warn >&2 "Activating media-libs/harfbuzz work-arounds ..."
			print >&2 "Before work-around, USE is '${aw_USE}' ..."
			aw_USE="${aw_USE:+"$( # <- Syntax
				echo " ${aw_USE} " | sed 's/ harfbuzz / / ; s/^ //'
			)"}-harfbuzz"
			print >&2 "After work-around, USE is '${aw_USE}'"
		fi
	fi

	#aw_pkgs='sys-apps/busybox sys-libs/libxcrypt virtual/libcrypt'
	#[ $(( aw_mode )) -ne 2 ] &&
	#	info >&2 "Checking for ${aw_pkgs} work-arounds ..."
	#aw_list=''
	#for aw_pkg in ${aw_pkgs}; do
	#	aw_list="${aw_list:+"${aw_list}|"}${aw_pkg#*"/"}|${aw_pkg}"
	#done
	#aw_pkg=''
	#if aw_pkg="$( # <- Syntax
	#		echo " ${aw_arg} " |
	#			sed 's/ /  /g' |
	#			grep -Eo -- " ([<>]?=|~)?(${aw_list})(-[^ ]+)? "
	#)" && [ -n "${aw_pkg:-}" ]
	#then
	#	if [ $(( aw_mode )) -eq 1 ]; then
	#		aw_pkg="$( echo "${aw_pkg}" | xargs -r )"
	#		warn >&2 "Adding post-package entries 'sys-libs/libxcrypt virtual/libcrypt'" \
	#			"due to presence of ${aw_pkg} ..."
	#		aw_post_pkgs="${aw_post_pkgs:+"${aw_post_pkgs} "}sys-libs/libxcrypt virtual/libcrypt"
	#	elif [ $(( aw_mode )) -eq 0 ]; then
	#		if ! command -V equery >/dev/null 2>&1; then
	#			warn >&2 "Unable to activate sys-apps/busybox, sys-libs/libxcrypt &" \
	#				"virtual/libcrypt work-arounds due to 'equery' missing"
	#		else
	#			if
	#				equery --no-color uses --ignore-l10n sys-apps/busybox |
	#					grep -q -- '^+static'
	#			then
	#				warn >&2 "Activating sys-apps/busybox work-arounds ..."
	#				printf '%s %s\n' 'virtual/libcrypt' '-static-libs' \
	#					>> /etc/portage/package.use/aw_busybox
	#				printf '%s %s\n' 'sys-libs/libxcrypt' '-static-libs' \
	#					>> /etc/portage/package.use/aw_busybox
	#			fi
	#		fi
	#	fi
	#fi

	aw_pkgs='sys-devel/gcc'
	[ $(( aw_mode )) -ne 2 ] &&
		info >&2 "Checking for ${aw_pkgs} work-arounds ..."
	aw_list=''
	for aw_pkg in ${aw_pkgs}; do
		aw_list="${aw_list:+"${aw_list}|"}${aw_pkg#*"/"}|${aw_pkg}"
	done
	aw_pkg=''
	#print >&2 "Matching ' ${aw_arg} ' against ' ([<>]?=|~)?(${aw_list})(-[^ ]+)? '"
	if aw_pkg="$( # <- Syntax
			echo " ${aw_arg} " |
				sed 's/ /  /g' |
				grep -Eo -- " ([<>]?=|~)?(${aw_list})(-[^ ]+)? "
		)" && [ -n "${aw_pkg:-}" ]
	then
		if [ $(( aw_mode )) -eq 1 ]; then
			aw_pkg="$( echo "${aw_pkg}" | xargs -r )"
			warn >&2 "Adding post-package entry 'sys-devel/gcc'" \
				"due to presence of ${aw_pkg} ..."
			aw_post_pkgs="${aw_post_pkgs:+"${aw_post_pkgs} "}sys-devel/gcc"
		elif [ $(( aw_mode )) -eq 0 ]; then
			aw_gcc_use=''
			warn >&2 "Activating sys-devel/gcc work-arounds ..."
			print >&2 "Before work-around, USE is '${aw_USE}' ..."
			# We want to abort with an unbound variable error if
			# ${use_essential_gcc} is referenced unassigned here...
			#
			# shellcheck disable=SC2154
			aw_gcc_use="$( # <- Syntax
				echo " ${use_essential_gcc} " |
					sed 's/ graphite / -graphite /g ; s/^ // ; s/ $//'
			)"
			aw_USE="${aw_USE:+"$( # <- Syntax
				echo " ${aw_USE} " |
					sed 's/ lib-only / / ; s/^ //'
			)"}-lib-only nls ${aw_gcc_use}"
			unset aw_gcc_use
			print >&2 "After work-around, USE is '${aw_USE}'"
		fi
	fi

	aw_pkgs='sys-libs/glibc'
	[ $(( aw_mode )) -ne 2 ] &&
		info >&2 "Checking for ${aw_pkgs} work-arounds ..."
	aw_list=''
	for aw_pkg in ${aw_pkgs}; do
		aw_list="${aw_list:+"${aw_list}|"}${aw_pkg#*"/"}|${aw_pkg}"
	done
	aw_pkg=''
	#print >&2 "Matching ' ${aw_arg} ' against ' ([<>]?=|~)?(${aw_list})(-[^ ]+)? '"
	if aw_pkg="$( # <- Syntax
			echo " ${aw_arg} " |
				sed 's/ /  /g' |
				grep -Eo -- " ([<>]?=|~)?(${aw_list})(-[^ ]+)? "
		)" && [ -n "${aw_pkg:-}" ]
	then
		if [ $(( aw_mode )) -eq 1 ]; then
			aw_pkg="$( echo "${aw_pkg}" | xargs -r )"
			warn >&2 "Adding post-package entry 'sys-libs/glibc'" \
				"due to presence of ${aw_pkg} ..."
			aw_post_pkgs="${aw_post_pkgs:+"${aw_post_pkgs} "}sys-libs/glibc"
		elif [ $(( aw_mode )) -eq 0 ]; then
			aw_gcc_use=''
			warn >&2 "Activating sys-libs/glibc work-arounds ..."
			print >&2 "Before work-around, USE is '${aw_USE}' ..."
			aw_USE="${aw_USE:+"$( # <- Syntax
				echo " ${aw_USE} " | sed 's/ compile-locales / / ; s/^ //'
			)"}-compile-locales"
			print >&2 "After work-around, USE is '${aw_USE}'"
		fi
	fi

	aw_pkgs='sys-libs/llvm-libunwind sys-devel/clang sys-devel/clang-common'
	[ $(( aw_mode )) -ne 2 ] &&
		info >&2 "Checking for ${aw_pkgs} work-arounds ..."
	aw_list=''
	for aw_pkg in ${aw_pkgs}; do
		aw_list="${aw_list:+"${aw_list}|"}${aw_pkg#*"/"}|${aw_pkg}"
	done
	aw_pkg=''
	#print >&2 "Matching ' ${aw_arg} ' against ' ([<>]?=|~)?(${aw_list})(-[^ ]+)? '"
	if aw_pkg="$( # <- Syntax
			echo " ${aw_arg} " |
				sed 's/ /  /g' |
				grep -Eo -- " ([<>]?=|~)?(${aw_list})(-[^ ]+)? "
		)" && [ -n "${aw_pkg:-}" ]
	then
		if [ $(( aw_mode )) -eq 0 ]; then
			warn >&2 "Activating sys-libs/llvm-libunwind work-arounds ..."
			print >&2 "Before work-around, USE is '${aw_USE}' ..."
			aw_USE="${aw_USE:+"$( # <- Syntax
				echo " ${aw_USE} " | sed 's/ default-compiler-rt / / ; s/^ //'
			)"}-default-compiler-rt"
			#aw_USE="${aw_USE:+"$( # <- Syntax
			#	echo " ${aw_USE} " | sed 's/ default-libcxx / / ; s/^ //'
			#)"}-default-libcxx"
			#aw_USE="${aw_USE:+"$( # <- Syntax
			#	echo " ${aw_USE} " | sed 's/ default-lld / / ; s/^ //'
			#)"}-default-lld"
			aw_USE="${aw_USE:+"$( # <- Syntax
				echo " ${aw_USE} " | sed 's/ llvm-libunwind / / ; s/^ //'
			)"}-llvm-libunwind"
			print >&2 "After work-around, USE is '${aw_USE}'"
		else
			aw_pkg="$( echo "${aw_pkg}" | xargs -r )"
			if [ $(( aw_mode )) -eq 2 ]; then
				# 'default-compiler-rt' is a USE-flag for
				# sys-devel/clang:14 but for sys-devel/clang-common
				# thereafter...
				warn >&2 "Adding post-package USE flags 'default-compiler-rt" \
					"default-libcxx default-lld llvm-libunwind' due to" \
					"presence of ${aw_pkg} ..."
				aw_post_use="${aw_post_use:+"${aw_post_use} "}default-compiler-rt default-libcxx default-lld llvm-libunwind"
				# aw_USE is only set when aw_mode == 0...
				if echo " ${USE} " |
						grep -Fq -- ' python_single_target_python'
				then
					flag=''
					for flag in ${USE}; do
						if echo "${flag}" |
								grep -Fq -- 'python_single_target_python'
						then
							aw_post_use="${aw_post_use:+"${aw_post_use} "}${flag}"
						fi
					done
					unset flag
				fi
			elif [ $(( aw_mode )) -eq 1 ]; then
				warn >&2 "Adding post-package entries 'sys-devel/clang' and" \
					"'sys-devel/clang-common' due to presence of" \
					"${aw_pkg} ..."
				aw_post_pkgs="${aw_post_pkgs:+"${aw_post_pkgs} "}sys-devel/clang sys-devel/clang-common"
			fi
		fi
	fi

	unset aw_pkg aw_list aw_pkgs aw_arg

	if [ $(( aw_mode )) -eq 2 ]; then
		if [ -n "${aw_post_use:-}" ]; then
			aw_post_use="$( # <- Syntax
				echo "${aw_post_use}" |
					xargs -rn 1 |
					sort -V |
					uniq |
					xargs -r
			)"
			#export post_use="${aw_post_use}"
			echo "${aw_post_use}"
		fi
	elif [ $(( aw_mode )) -eq 1 ]; then
		if [ -n "${aw_post_pkgs:-}" ]; then
			aw_post_pkgs="$( # <- Syntax
				echo "${aw_post_pkgs}" |
					xargs -rn 1 |
					sort -V |
					uniq |
					xargs -r
			)"
			#export post_pkgs="${aw_post_pkgs}"
			echo "${aw_post_pkgs}"
		fi
	else
		if [ -n "${aw_USE:-}" ]; then
			# We actually don't want to re-order arguments...
			#aw_USE="$( # <- Syntax
			#	echo "${aw_USE}" |
			#		xargs -rn 1 |
			#		sort -V |
			#		uniq |
			#		xargs -r
			#)"
			#export USE="${aw_USE}"
			echo "${aw_USE}"
		fi
	fi
	unset aw_USE aw_post_pkg
}  # applyworkarounds

clearworkarounds() {
	rm -rf /etc/portage/package.use/aw_* 2>/dev/null || :
}  # clearworkarounds

git_safedirectory_markall() {
	# Silence 'safe-directory' warnings...
	if command -v git >/dev/null 2>&1; then
		# We don't know when (if at all) we might find that 'git' is installed,
		# so we'll end up needing to call this multiple times - so let's see if
		# the required directive is already present, and only make changes
		# (which git will accumulate rather than deduplicate) if needed...
		#
		grep -q -- '^\s*directory\s*=\s*\*$' ~/.gitconfig 2>/dev/null ||
			git config --global --add safe.directory '*'
	fi
}  # git_safedirectory_markall

do_container_setup() {
	do_locale_gen
	echo
	if command -v env-update >/dev/null 2>&1; then
		LC_ALL='C' env-update 2>/dev/null
	fi
	if [ -e /usr/gawk ] || [ -e /usr/bin/gawk ]; then
		# Superseded by app-alternatives/awk...
		#
		if [ -e /usr/bin/eselect ] &&
				[ -s /usr/share/eselect/modules/awk.eselect ]
		then
			eselect awk set gawk
		fi
	fi
	# shellcheck disable=SC2015
	[ -d /etc/env.d/binutils ] &&
		command -v binutils-config >/dev/null 2>&1 &&
			ROOT='' binutils-config 1 2>/dev/null |
				grep -v -- '^\s*$' || :
	echo
	[ -d /etc/env.d/gcc ] &&
		command -v gcc-config >/dev/null 2>&1 &&
			ROOT='' gcc-config 1
	echo

	# shellcheck disable=SC2015
	command -v etc-update >/dev/null 2>&1 &&
		etc-update --automode -5 2>/dev/null |
			grep -Fv -- 'Nothing left to do; exiting' || :
}  # do_container_setup

do_emerge() {
	#inherit USE ROOT
	do_emerge_arg=''
	do_emerge_args=''
	do_emerge_rc=0

	for do_emerge_arg in "${@:-}"; do
		[ -n "${do_emerge_arg:-}" ] &&
			do_emerge_args="${do_emerge_args:+"${do_emerge_args} "}'${do_emerge_arg}'"
	done

	[ -n "${do_emerge_args:-}" ] || return 1

	if [ $(( $(
		localedef --list-archive |
			grep -cF -e 'utf8' -e 'UTF-8'
	) )) -eq 0 ]
	then
		mkdir -p /usr/lib/locale
		localedef --replace -f UTF-8 -i C C.UTF-8 --force
	fi

	export USE

	print "Running \"emerge ${do_emerge_args}\"${USE:+" with USE='${USE}'"}" \
		"with ROOT='${ROOT}'"

	# Not required when all arguments are quoted...
	#
	#do_emerge_args="$( echo "${do_emerge_args}" | sed -r 's/(<|>)/\\\1/g' )"

	export LC_ALL='C' FEATURES='-fail-clean'
	# shellcheck disable=SC2116
	do_emerge_str="$( echo "LC_ALL='${LC_ALL}'" \
		" FEATURES='${FEATURES}'" \
		" USE='${USE}'" \
		" ${busybox_disclaimer:-} ;" \
		" emerge" \
			" ${opts:+"${opts} "}${do_emerge_args}"
	)"
	eval "${do_emerge_str}" ||
		do_emerge_rc=${?}

	unset do_emerge_args
	return ${do_emerge_rc}
}  # do_emerge

# Prelink is no longer supported :(
#
#do_prelink() {
#	# http://www.gentoo.org/doc/en/prelink-howto.xml
#	PRELINK_OPTS='-mRf'
#
#	[ -x /usr/sbin/prelink ] || return 0
#
#	[ -e /etc/prelink.cache] && rm /etc/prelink.cache
#
#	/usr/sbin/prelink -av ${PRELINK_OPTS}
#}  # prelink

do_locale_gen() {
	if command -v locale-gen >/dev/null 2>&1; then
		case "${JOBS:-}" in
			0|1|'*')
				ROOT='' locale-gen --update
				;;
			[0-9]*)
				ROOT='' locale-gen --update --jobs "${JOBS}"
				;;
			''|*)
				ROOT='' locale-gen --update --jobs "${DEFAULT_JOBS}"
				;;
		esac
	fi
}  # do_locale_gen

if echo " ${*:-} " | grep -Fq -- ' --finalise-container '; then
	print "Finalising container image ..."
	do_container_setup
	rm -r /var/db/repo
	exit ${?}
fi

if [ -n "${DEV_MODE:-}" ]; then
	cat <<EOF

*******************************************************************************
*                                                                             *
* OPERATING IN DEV_MODE                                                       *
*                                                                             *
* This script is running as it exists on-disk, overriding the container image *
* contents.  Do not use the output of this mode for reliable builds.          *
*                                                                             *
*******************************************************************************

EOF
fi

[ -n "${trace:-}" ] && set -o xtrace

if set | grep -q -- '=__[A-Z]\+__$'; then
	die "Unexpanded variable(s) in environment: $( # <- Syntax
		set | grep -- '=__[A-Z]\+__$' | cut -d'=' -f 1 | xargs -r
	)"
fi

# shellcheck disable=SC2015,SC1091,SC1090
[ -s "${environment_file}" ] &&
	. "${environment_file}" ||
		die "gentoo-build:entrypoint.sh Unable to source" \
			"'${environment_file}': ${?}"

# shellcheck disable=SC1091
[ -s /etc/profile ] && . /etc/profile

if printf '%s' " ${*:-} " | grep -Fq -- ' --verbose-build '; then
	parallel='--jobs=1 --quiet-build=n'
else
	if [ -n "${JOBS:-}" ]; then
		case "${JOBS}" in
			0|1)
				parallel=''
				;;
			'*')
				parallel='--jobs'
				;;
			[0-9]*)
				parallel="--jobs=${JOBS}"
				;;
			*)
				parallel="--jobs=${DEFAULT_JOBS}"
				;;
		esac
	else
		parallel="--jobs=${DEFAULT_JOBS}"
	fi
fi

if [ -z "${MAXLOAD:-}" ] || [ "${MAXLOAD:-}" != '0' ]; then
	parallel="${parallel:+"${parallel} "}--load-average=${MAXLOAD:-"${DEFAULT_MAXLOAD}"}"
fi

# Allow USE='make-symlinks' and merging with ROOT='/' without erroring-out for
# safety reasons...
#
#busybox_disclaimer='VERY_BRAVE_OR_VERY_DUMB=yes'

# Specify our installation ROOT...
#
service_root='/service'

if [ -n "${DEBUG:-}" ]; then
	# shellcheck disable=SC2013
	for f in $( grep -Rl -- 'collision' log/docker.*.log ); do
		sed '\x1b\[[0-9;]*m//g' "${f}" |
			awk --assign p=0 '
				/Detected file collision\(s\):$/ { p = 2 } ;
				/^ \* $/ { p = p - 1 } ;
				( 1 == p ) { print $2 } ;
			'
	done |
		xargs -rn 1 dirname |
			sed 's|/c.i-php.\../|/*/| ; s|/spamassassin/|/*/| ; s|$|/*|' |
			sort |
			uniq
fi
COLLISION_IGNORE="$( echo "${COLLISION_IGNORE:-"/lib/modules/*"}
	/bin/cpio
	/usr/bin/awk
	/usr/bin/bc
	/usr/bin/dc
	/usr/bin/lexx
	/usr/bin/ninja
	/usr/bin/yacc
	/etc/env.d/04gcc-x86_64-pc-linux-gnu
	/etc/env.d/gcc/config-x86_64-pc-linux-gnu
	/usr/lib/locale/locale-archive
	/var/lib/portage/home/*
	${service_root}/bin/*
	${service_root}/etc/php/*/ext-active/*
	${service_root}/sbin/*
	${service_root}/usr/bin/*
	${service_root}/usr/share/*/*
	${service_root}/var/lib/*/*
" | xargs -r )"
export COLLISION_IGNORE

TUSE='' pkg_use_pkg='' pkg_use_use='' pkg_use_file=''
pkg_mask_pkg='' pkg_mask_file='' extra_file='' extra_files=''
force_python=''
pre_remove='' pre_pkgs='' pre_use=''
post_pkgs='' post_use='' post_remove=''
rebuild='' depclean_extra='' depclean_exclude='' intent='keep'
depclean=0 change_sysroot=0 pkg_use=0 pkg_mask=0 no_use=0 rc=0
for arg in "${@}"; do
	#print "Read argument '${arg}'"

	shift
	case "${arg}" in
		--force-python=*)
			force_python="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			if ! echo "${force_python:-}" |
					grep -q -- '^python[2-9]_[0-9]$'
			then
				die "Portage python token '${force_python:-}' is not valid"
			fi
			continue
			;;
		--no-package-use)
			no_use=1
			continue
			;;
		--pre-remove=*)
			pre_remove="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			continue
			;;
		--pre-pkgs=*)
			pre_pkgs="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			continue
			;;
		--pre-use=*)
			pre_use="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			continue
			;;
		--post-pkgs=*)
			post_pkgs="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			continue
			;;
		--post-use=*)
			post_use="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			continue
			;;
		--rebuild=*)
			rebuild="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			continue
			;;
		--post-remove=*)
			post_remove="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			continue
			;;
		--depclean)
			depclean=1
			continue
			;;
		--depclean-extra=*)
			depclean_extra="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			continue
			;;
		--depclean-exclude=*)
			depclean_exclude="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			continue
			;;
		--intent=*)
			intent="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			continue
			;;
		--sysroot)
			change_sysroot=1
			continue
			;;
		--verbose-build)
			continue
			;;
		--with-use=*)
			TUSE="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			continue
			;;
		--with-pkg-use=*|--with-package-use=*)
			# e.g. --with-pkg-use='sys-apps/coreutils -hostname'
			#
			pkg_use=1
			pkg_use_use="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			pkg_use_pkg="$( # <- Syntax
				echo "${pkg_use_use:-}" | cut -d' ' -f 1
			)"
			pkg_use_use="$( # <- Syntax
				echo "${pkg_use_use:-}" | cut -d' ' -f 2-
			)"
			if [ -z "${pkg_use_pkg:-}" ] || [ -z "${pkg_use_use:-}" ]; then
				die "Unable to extract package and USE flags from '${arg}'"
			fi
			mkdir -p /etc/portage/package.use
			pkg_use_file="/etc/portage/package.use/$( # <- Syntax
				echo "${pkg_use_pkg}" | cut -d'/' -f 2-
			)"
			printf '%s %s\n' \
				"${pkg_use_pkg}" \
				"${pkg_use_use}" >> "${pkg_use_file}"
			warn "Applied override USE flag(s):"
			warn "  ${pkg_use_file}:"
			warn "$( sed 's/^/    /' < "${pkg_use_file}" )"
			extra_files="${extra_files:+"${extra_files} "}${pkg_use_file}"
			pkg_use_file='' pkg_use_pkg='' pkg_use_use=''
			continue
			;;
		--with-pkg-mask=*|--with-package-mask=*)
			pkg_mask=1
			pkg_mask_pkg="$( # <- Syntax
				printf '%s' "${arg}" | sed -z 's/^[^=]*=//' | tr -d '\n'
			)"
			mkdir -p /etc/portage/package.mask
			#pkg_mask_file="/etc/portage/package.mask/$( # <- Syntax
			#	echo "${pkg_mask_pkg}" | cut -d'/' -f 2-
			#)"
			pkg_mask_file="/etc/portage/package.mask/extra.mask"
			printf '%s\n' "${pkg_mask_pkg}" >> "${pkg_mask_file}"
			#warn "Applied package mask(s):"
			#warn "  ${pkg_mask_file}:"
			##warn "$( sed 's/^/    /' < "${pkg_mask_file}" )"
			#line=''
			#cat "${pkg_mask_file}" | while read -r line; do
			#	warn "    ${line}"
			#done
			#unset line
			if ! echo " ${extra_files:-} " |
					grep -Fq -- " ${pkg_mask_file} "
			then
				extra_files="${extra_files:+"${extra_files} "}${pkg_mask_file}"
			fi
			pkg_mask_pkg=''
			continue
			;;
		*)
			set -- "${@}" "${arg}"
			;;
	esac
done
unset pkg_mask_pkg pkg_use_file pkg_use_pkg pkg_use_use arg

case "${intent}" in
	'keep')
		:
		;;
	'tmp'|'temp'|'discard')
		intent='tmp'
		if [ $(( depclean )) -ne 0 ]; then
			ewarn "Disabling --depclean for invocation with 'discard' intent"
			depclean=0
		fi
		;;
	*)	die "Unknown intent '${intent}' - recognised values are" \
			"'keep' & 'discard'"
		;;
esac

if [ ! -f /etc/locale.gen ] || [ ! -s /etc/locale.gen ]; then
	cat >/etc/locale.gen <<-EOF
		en_GB ISO-8859-1
		en_GB.ISO-8859-15 ISO-8859-15
		en_GB.UTF-8 UTF-8
		en_US ISO-8859-1
		en_US.UTF-8 UTF-8
	EOF
fi

if [ -e /etc/portage/repos.conf.host ]; then
	echo
	info "Mirroring host repos.conf to container ..."
	if [ -e /etc/portage/repos.conf ]; then
		if [ -d /etc/portage/repos.conf ]; then
			for f in /etc/portage/repos.conf/*; do
				umount -q "${f}" || :
			done
		fi
		umount -q /etc/portage/repos.conf || :
		rm -rf /etc/portage/repos.conf || :

		[ -e /etc/portage/repos.conf ] &&
			mv /etc/portage/repos.conf /etc/portage/repos.conf.disabled
	fi
	cp -a /etc/portage/repos.conf.host /etc/portage/repos.conf ||
		die "Can't copy host repos.conf: ${?}"
fi

if [ $(( pkg_mask )) -ne 0 ]; then
	warn "Applied package mask(s):"
	warn "  ${pkg_mask_file}:"
	#warn "$( sed 's/^/    /' < "${pkg_mask_file}" )"
	line=''
	while read -r line; do
		warn "    ${line}"
	done < "${pkg_mask_file}"
	unset line pkg_mask_file
fi

if [ $(( no_use )) -ne 0 ]; then
	# My suspicion is that package.use contents are interfering with
	# environment USE flags...
	#
	if [ -e /etc/portage/package.use ]; then
		if [ $(( pkg_use )) -ne 0 ]; then
			warn "'--with-pkg-use' option will be overridden by" \
				"'--no-package-use'"
		fi
		echo
		warn "Removing default '/etc/portage/package.use' settings"
		mv /etc/portage/package.use /etc/portage/package.use.disabled
	fi
fi

# We currently support two methods of portage configuration override:
#
#  /etc/portage/<conf>.override/file replaces /etc/portage/<conf>/file
#  /etc/portage/<conf>.override/file.header prepended to /etc/portage/<conf>/file
#
# ... others may be added as necessary.
#
override_dir='' target_dir='' override_file=''
find '/etc/portage/' \
		-mindepth 1 -maxdepth 1 \
		-type d \
		-name '*.override' \
		-print |
	while read -r override_dir
do
	target_dir="$( echo "${override_dir}" | sed 's/\.override$//' )"

	if [ -e "${target_dir}" ]; then
		warn "Files deployed from '${override_dir}' will update or replace" \
			"files in '${target_dir}' ..."
	fi

	find "${override_dir}/" \
			-mindepth 1 -maxdepth 1 \
			-type f \
			-not -name '*.header' \
			-print |
		while read -r override_file
	do
		override_file="$( basename "${override_file}" )"
		[ -d "${target_dir}" ] ||
			mkdir -p "${target_dir}"
		if [ -f "${target_dir}/${override_file}" ]; then
			info "Overwriting file '${target_dir}/${override_file}' with" \
				"data from '${override_dir}/${override_file}' ..."
		elif [ -e "${target_dir}/${override_file}" ]; then
			warn "Replacing non-file object" \
				"'${target_dir}/${override_file}' with file" \
				"'${override_dir}/${override_file}' ..."
		else
			print "Adding new file '${override_dir}/${override_file}' as" \
				"'${target_dir}/${override_file}' ..."
		fi
		[ -e "${target_dir}/${override_file}" ] &&
			rm -rf "${target_dir:?}/${override_file}"
		cp -a "${override_dir}/${override_file}" "${target_dir}/" ||
			die "File copy from '${override_dir}/${override_file}' to" \
				"'${target_dir}/' failed: ${?}"
	done  # override_file

	find "${override_dir}/" \
			-mindepth 1 -maxdepth 1 \
			-type f \
			-name '*.header' \
			-print |
		while read -r override_file
	do
		override_file="$( basename "${override_file%".header"}" )"
		[ -d "${target_dir}" ] ||
			mkdir -p "${target_dir}"
		if ! [ -e "${target_dir}/${override_file}" ]; then
			warn "No source file for header" \
				"'${override_dir}/${override_file}.header', deploying as new" \
				"file ..."
			cp -a "${override_dir}/${override_file}.header" \
					"${target_dir}/${override_file}" ||
				die "File copy from '${override_dir}/${override_file}.header'" \
					"to '${target_dir}/${override_file}' failed: ${?}"
		elif ! [ -f "${target_dir}/${override_file}" ]; then
			die "Could not append to '${target_dir}/${override_file}', which" \
				"exists but is not a file"
		else
			if ! cat "${override_dir}/${override_file}.header" \
					"${target_dir}/${override_file}" > \
					"${target_dir}/${override_file}.new" &&
				mv "${target_dir}/${override_file}.new" \
						"${target_dir}/${override_file}"
			then
				die "Could not append" \
					"'${override_dir}/${override_file}.header' to existing" \
					"file '${target_dir}/${override_file}': ${?}"
			fi
		fi
	done  # override_file
done  # override_dir
unset override_file target_dir override_dir

if command -v pypy3 >/dev/null 2>&1; then
	print "Enabling pypy3 support for portage ..."
	mkdir -p /etc/python-exec
	echo 'pypy3' >> /etc/python-exec/emerge.conf
	print "$( LC_ALL='C' emerge --info | head -n 1 2>&1 )"
fi

#warn >&2 "Inherited USE-flags: '${USE:-}'"

# post_use should be based on the original USE flags, without --with-use
# additions...
#
if [ -n "${post_use:-}" ]; then
	if ! printf ' %s ' "${post_use:-}" | grep -Fq -- ' -* '; then
		post_use="${USE:+"${USE} "}${post_use:-}"
	fi
else
	post_use="${USE:-}"
fi
if [ -n "${use_essential:-}" ]; then
	if ! echo "${post_use:-}" |
			grep -Fq -- "${use_essential}"
	then
		post_use="${post_use:+"${post_use} "}${use_essential}"
	fi
fi
if [ -n "${TUSE:-}" ]; then
	if ! printf '%s' " ${TUSE} " | grep -Fq -- ' -* '; then
		TUSE="${USE:+"${USE} "}${TUSE}"
	fi
	if [ -n "${use_essential:-}" ] &&
			echo "${TUSE}" | grep -Fq -- "${use_essential}"
	then
		USE="${TUSE}"
	else
		USE="${TUSE} ${use_essential}"
	fi
	export USE
fi
unset TUSE

info="$( LC_ALL='C' emerge --info --verbose=y )"
echo
echo 'Resolved build variables for build stage:'
echo '----------------------------------------'
echo
#echo "ROOT                = $( # <- Syntax
#	echo "${info}" | grep -- '^ROOT=' | cut -d'=' -f 2-
#)"
#echo "SYSROOT             = $( # <- Syntax
#	echo "${info}" | grep -- '^SYSROOT=' | cut -d'=' -f 2-
#)"
echo "PORTAGE_CONFIGROOT  = $( # <- Syntax
	echo "${info}" | grep -- '^PORTAGE_CONFIGROOT=' | cut -d'=' -f 2-
)"
echo
echo "${info}" | format 'FEATURES'
echo "${info}" | format 'ACCEPT_LICENSE'
echo "${info}" | format 'ACCEPT_KEYWORDS'
echo "${info}" | format 'USE'
echo "MAKEOPTS            = $( # <- Syntax
	echo "${info}" | grep -- '^MAKEOPTS=' | cut -d'=' -f 2-
)"
echo
echo "${info}" | format 'EMERGE_DEFAULT_OPTS'
echo
echo "DISTDIR             = $( # <- Syntax
	echo "${info}" | grep -- '^DISTDIR=' | cut -d'=' -f 2-
)"
echo "PKGDIR              = $( # <- Syntax
	echo "${info}" | grep -- '^PKGDIR=' | cut -d'=' -f 2-
)"
echo "PORTAGE_LOGDIR      = $( # <- Syntax
	echo "${info}" | grep -- '^PORTAGE_LOGDIR=' | cut -d'=' -f 2-
)"
echo
unset info

package='app-shells/bash'
opts='--tree'
# shellcheck disable=SC2015
printf ' %s ' "${*}" | grep -Fq -- ' --nodeps ' && opts='' || :
export opts

if [ -n "${ECLASS_OVERRIDE:-}" ]; then
	echo
	warn "Applying eclass override for repo '${ECLASS_OVERRIDE}' ..."

	(
		for ROOT in $( echo '/' "${ROOT:-}" | xargs -n 1 | sort | uniq ); do
			if [ -e "${ROOT%"/"}/etc/portage/repos.conf" ]; then
				if grep -qR -- '^\s*eclass-overrides' \
					"${ROOT%"/"}/etc/portage/repos.conf"
				then
					echo "INFO:  Adding eclass override '${ECLASS_OVERRIDE}'" \
						"to repos.conf for installation root '${ROOT}' ..."
					if [ -f "${ROOT%"/"}/etc/portage/repos.conf" ]; then
						sed -e "/^\s*eclass-overrides/ s/\(\s*$\|\s*#.*$\)/ ${ECLASS_OVERRIDE}\1/" \
								-i "${ROOT%"/"}/etc/portage/repos.conf" ||
							die "Failed to update '${ROOT%"/"}/etc/portage/repos.conf': ${?}"
					elif [ -f "${ROOT%"/"}/etc/portage/repos.conf/DEFAULT.conf" ]
					then
						sed -e "/^\s*eclass-overrides/ s/\(\s*$\|\s*#.*$\)/ ${ECLASS_OVERRIDE}\1/" \
								-i "${ROOT%"/"}/etc/portage/repos.conf/DEFAULT.conf" ||
							die "Failed to update '${ROOT%"/"}/etc/portage/repos.conf/DEFAULT.conf': ${?}"
					else
						die "Could not find repo configuration file to" \
							"update for installation root '${ROOT}'"
					fi
				else
					echo "Setting eclass override '${ECLASS_OVERRIDE}' in" \
						"repos.conf for installation root '${ROOT}' ..."
					if [ -f "${ROOT%"/"}/etc/portage/repos.conf" ]; then
						printf '\neclass-overrides = %s\n' "${ECLASS_OVERRIDE}" \
								>>"${ROOT%"/"}/etc/portage/repos.conf" ||
							die "Failed to update '${ROOT%"/"}/etc/portage/repos.conf': ${?}"
					elif [ -f "${ROOT%"/"}/etc/portage/repos.conf/DEFAULT.conf" ]
					then
						printf '\neclass-overrides = %s\n' "${ECLASS_OVERRIDE}" \
								>>"${ROOT%"/"}/etc/portage/repos.conf/DEFAULT.conf" ||
							die "Failed to update '${ROOT%"/"}/etc/portage/repos.conf/DEFAULT.conf': ${?}"
					else
						die "Could not find repo configuration file to" \
							"update for installation root '${ROOT}'"
					fi
				fi
				{
					echo "Active overrides:"
					grep -HR -- '^\s*eclass-overrides' \
						"${ROOT%"/"}/etc/portage/repos.conf/"
				} | sed 's/^/       /'
			else
				warn "Could not find repo configuration for installation" \
					"root '${ROOT}'"
			fi
		done
	)
fi


if [ -n "${pre_remove:-}" ]; then
	pkg_remove 'pre-installation' "${pre_remove}"
fi

if [ -n "${force_python:-}" ]; then
	pre_pkgs="${pre_pkgs:+"${pre_pkgs} "}dev-lang/python:$( echo "${force_python}" | sed 's/^python// ; s/_/./' )"
fi
if [ -n "${pre_pkgs:-}" ]; then
	echo
	echo " * Building specified pre-installation package(s) '${pre_pkgs}' ..."
	(
		if [ -n "${pre_use:-}" ]; then
			if ! printf ' %s ' "${pre_use}" | grep -Fq -- ' -* '; then
				pre_use="${USE:+"${USE} "}${pre_use}"
			fi
			if [ -n "${use_essential:-}" ] &&
					echo "${pre_use}" |
						grep -Fq -- "${use_essential}"
			then
				USE="${pre_use}"
			else
				USE="${pre_use} ${use_essential}"
			fi
		fi
		if echo " ${pre_pkgs} " |
				grep -Pq -- ' ([=<>!~][=!]?)?(sys-devel/)?gcc(-[0-9.r-]+)?[*]?(:(?:[*]|[0-9.]*)=?)? ' >dev/null 2>&1
		then
			# shellcheck disable=SC2154
			USE="${USE:+"${USE} "}${use_essential_gcc}"
		fi
		export ROOT='/'
		export USE
		export FEATURES="${FEATURES:+"${FEATURES} "}-fail-clean"
		export LC_ALL='C'

		info="$( LC_ALL='C' emerge --info --verbose=y )"
		echo
		echo 'Resolved build variables for pre-installation packages:'
		echo '------------------------------------------------------'
		echo
		echo "ROOT                = $( echo "${info}" | grep -- '^ROOT=' | cut -d'=' -f 2- )"
		echo "SYSROOT             = $( echo "${info}" | grep -- '^SYSROOT=' | cut -d'=' -f 2- )"
		echo "${info}" | format 'FEATURES'
		echo "${info}" | format 'USE'
		unset info

		# shellcheck disable=SC2086
		if ! ( do_emerge \
				--ignore-default-opts \
				  ${parallel} \
				--binpkg-changed-deps=y \
				--binpkg-respect-use=y \
				--buildpkg=y \
				--color=y \
				--keep-going=y \
				--quiet-build=y \
				  ${opts:-} \
				--usepkg=y \
				--verbose-conflicts \
				--verbose=y \
				--with-bdeps-auto=n \
				--with-bdeps=n \
			-- ${pre_pkgs}
				#--binpkg-changed-deps=y \
				#--rebuild-if-new-slot=y \
				#--rebuilt-binaries=y \
		)
		then
			savefailed
			exit 1
		fi

		git_safedirectory_markall

		if [ -n "${force_python:-}" ]; then
			# shellcheck disable=SC2086
			if ! ( do_emerge \
					--ignore-default-opts \
					  ${parallel} \
					--buildpkg=n \
					--color=y \
					--keep-going=y \
					--quiet-build=y \
					  ${opts:-} \
					--usepkg=n \
					--verbose-conflicts \
					--verbose=y \
					--with-bdeps-auto=n \
					--with-bdeps=n \
				-- dev-lang/python-exec
			)
			then
				savefailed
				exit 1
			fi
		fi  # [ -n "${force_python:-}" ]
	)
fi  # [ -n "${pre_pkgs:-}" ]

if [ -e /usr/gawk ] || [ -e /usr/bin/gawk ]; then
	# Superseded by app-alternatives/awk...
	#
	if [ -e /usr/bin/eselect ] &&
			[ -s /usr/share/eselect/modules/awk.eselect ]
	then
		eselect awk set gawk
	fi
fi
[ -d /etc/env.d/gcc ] && ROOT='/' gcc-config 1
[ -d /etc/env.d/binutils ] &&
	command -v binutils-config >/dev/null 2>&1 &&
	ROOT='/' binutils-config 1
# shellcheck disable=SC1091
[ -s /etc/profile ] && . /etc/profile

echo
echo " * Ensuring base packages in '${service_root}/' ROOT are current:"
echo

# Replace default file with patched version
#
if [ -s /etc/bash/bashrc ]; then
	mkdir -p "${service_root}"/etc/bash
	cp /etc/bash/bashrc "${service_root}"/etc/bash/
fi

# Try not to use too much time building additional locales
#
if ! [ -f /etc/locale.gen ]; then
	warn "File '/etc/locale.gen' is missing - expect a very large" \
		"'locale-archive'"
else
	mkdir -p "${service_root}"/etc
	cp /etc/locale.gen "${service_root}"/etc/
fi

#time (
(
	ROOT="${service_root}"
	FEATURES="${FEATURES:+"${FEATURES} "}-fail-clean"
	USE="-* -lib-only make-symlinks mdev openmp timezone-tools"
	# ... we also need 'http2' if any rust packages need to be updated
	USE="${USE} http2"
	LC_ALL='C'
	export ROOT FEATURES USE LC_ALL

	for extra_file in ${extra_files}; do
		if [ -e "${extra_file}" ] && ! [ -e "${ROOT}${extra_file}" ]; then
			mkdir -p "$( dirname "${ROOT}${extra_file}" )"
			cp --verbose "${extra_file}" "${ROOT}${extra_file}"
		fi
	done
	unset extra_file

	info="$( LC_ALL='C' emerge --info --verbose=y )"
	echo
	echo 'Resolved build variables for service packages:'
	echo '---------------------------------------------'
	echo
	echo "ROOT                = $( # <- Syntax
		echo "${info}" | grep -- '^ROOT=' | cut -d'=' -f 2-
	)"
	echo "SYSROOT             = $( # <- Syntax
		echo "${info}" | grep -- '^SYSROOT=' | cut -d'=' -f 2-
	)"
	echo "${info}" | format 'FEATURES'
	echo "${info}" | format 'USE'
	unset info

	# sys-apps/shadow is needed for /sbin/nologin;
	#
	# sys-apps/coreutils needed for cat/chmod;
	#
	#service_pkgs='virtual/libc app-shells/bash sys-apps/shadow sys-apps/coreutils'
	#
	# ... both now superseded by sys-apps/busybox with USE='make-symlinks'
	# (although this does require disabling collision-detection on other
	#  system packages which install the actual, non-bb, binaries)
	#
	# If we don't build libarchive support here (without USE='lz4'), then when
	# the package is updated we hit a dependency issue whereby cmake requires
	# libarchive requires lz4 requires cmake <sigh>).
	#
	# N.B. This block *requires* that package atoms be fully-qualified,
	#      including category names.
	#
	service_pkgs='virtual/libc sys-apps/busybox'
	if [ -n "${pre_remove:-}" ]; then
		if ! echo "${pre_remove}" |
				grep -Fq -- 'dev-libs/openssl'
		then
			service_pkgs="${service_pkgs} app-arch/libarchive"
		fi
	fi

	service_pkgs="${service_pkgs} dev-lang/python-exec"
	if [ -n "${force_python:-}" ]; then
		service_pkgs="${service_pkgs} dev-lang/python:$( # <- Syntax
			echo "${force_python}" | sed 's/^python// ; s/_/./'
		)"
	fi

	exclude=''
	if [ -n "${pre_remove}" ]; then
		for pkg in ${pre_remove}; do
			exclude="${exclude:+"${exclude} "}--exclude ${pkg}"
		done
		unset pkg
	fi

	echo
	echo " * Packages to install: ${service_pkgs}"
	echo " * Packages to exclude: ${pre_remove:-"<none>"}"

	# 'minimal' required to avoid:
	#    sys-libs/glibc ->
	#    sys-apps/gentoo-functions ->
	#    sys-apps/busybox ->
	#    virtual/libc ->
	#    sys-libs/glibc
	# circular dependency...
	#
	# shellcheck disable=SC2086,SC2046
	(
		export USE="${USE:+"${USE} "}minimal"
		if ! ( do_emerge \
				--ignore-default-opts \
				  ${parallel} \
				--binpkg-changed-deps=y \
				--binpkg-respect-use=y \
				--buildpkg=y \
				--color=y \
				--keep-going=y \
				--rebuild-if-new-slot=y \
				--quiet-build=y \
				--update \
				  ${opts:-} \
				--usepkg=y \
				--verbose=y \
				--verbose-conflicts \
				--with-bdeps=n \
				--with-bdeps-auto=n \
				${exclude:-} \
			-- ${service_pkgs}
				#--rebuilt-binaries=y \
		)
		then
			savefailed
			exit 1
		fi
	) || exit ${?}

	git_safedirectory_markall

	# Tallies against 'time' call immediately before subshell invocation...
	#echo "Time spent updating build container:"
)

if [ -n "${ROOT:-}" ] && [ "${ROOT}" != '/' ]; then
	if [ $(( change_sysroot )) -ne 0 ]; then
		export SYSROOT="${ROOT}"
	fi

	if [ -e "${ROOT}"/usr/gawk ] || [ -e "${ROOT}"/usr/bin/gawk ]; then
		# Superseded by app-alternatives/awk...
		#
		if
			[ -e "${ROOT}"/usr/bin/eselect ] &&
			[ -s "${ROOT}"/usr/share/eselect/modules/awk.eselect ]
		then
			eselect awk set gawk
		fi
	fi
	[ -d "${ROOT}"/etc/env.d/gcc ] &&
		gcc-config 1
	[ -d "${ROOT}"/etc/env.d/binutils ] &&
		command -v binutils-config >/dev/null 2>&1 &&
			binutils-config 1
	# shellcheck disable=SC1091
	[ -s "${ROOT}"/etc/profile ] &&
		. "${ROOT}"/etc/profile
fi

(
	for ROOT in $( # <- Syntax
			echo '/' "${ROOT:-}" |
				xargs -n 1 |
				sort |
				uniq
	); do
		export ROOT
		if [ -x "${ROOT%"/"}"/usr/bin/eselect ]; then
			if [ -s "${ROOT%"/"}"/usr/share/eselect/modules/python.eselect ]
			then
				echo "Setting python implementation for installation" \
					"root '${ROOT}' ..."
				mkdir -p "${ROOT%"/"}"/etc/python-exec

				eselect python cleanup
				eselect python update --if-unset
				if [ -n "${force_python:-}" ]; then
					print "python-exec supported interpreters: $( # <- Syntax
						python-exec2c -l | xargs echo
					)"
					if [ "${force_python#"python2"}" != "${force_python}" ]
					then
						eselect python set --python2 "$( # <- Syntax
							echo "${force_python}" | tr '_' '.'
						)"
					else
						eselect python set "$( # <- Syntax
							echo "${force_python}" | tr '_' '.'
						)"
					fi
				fi
				#eselect python list
				#eselect python --show --python2
				#eselect python --show --python3
			fi
			if [ -s "${ROOT%"/"}"/usr/share/eselect/modules/java-vm.eselect ]
			then
				echo "Setting Java VM for installation root '${ROOT}' ..."
				eselect java-vm set system 1
				[ $(( $( id -u ) )) -eq 0 ] ||
					eselect java-vm set user 1
			fi
		fi
		# python-exec now no longer requires the 'eselect' interface...
		#
		if [ -n "${force_python:-}" ]; then
			if [ -s "${ROOT%"/"}"/etc/python-exec/python-exec.conf ]; then
				sed -e 's/^\([^#]\)/#\1/' \
					-i "${ROOT%"/"}"/etc/python-exec/python-exec.conf
			fi
			echo "${force_python}" >> \
				"${ROOT%"/"}"/etc/python-exec/python-exec.conf
		fi
	done
)
if [ -n "${force_python:-}" ]; then
	export PYTHON_COMPAT_OVERRIDE="${force_python}"
fi

case "${1:-}" in
	sh|/bin/sh)
		[ -n "${2:-}" ] && shift

		exec /bin/sh "${@}"
		;;

	bash|/bin/bash)
		[ -n "${2:-}" ] && shift

		exec /bin/bash "${@}"
		;;

	'')
		echo
		echo " * Building default '${package}' package ..."
		echo

		info="$( LC_ALL='C' emerge --info --verbose=y )"
		echo
		echo 'Resolved build variables for default package:'
		echo '---------------------------------------------'
		echo
		echo "ROOT                = $( # <- Syntax
			echo "${info}" | grep -- '^ROOT=' | cut -d'=' -f 2-
		)"
		echo "SYSROOT             = $( # <- Syntax
			echo "${info}" | grep -- '^SYSROOT=' | cut -d'=' -f 2-
		)"
		echo "${info}" | format 'FEATURES'
		echo "${info}" | format 'USE'
		echo "${info}" | format 'PYTHON_SINGLE_TARGET'
		echo "${info}" | format 'PYTHON_TARGETS'
		echo
		target=''
		for target in $( # <- Syntax
			echo "${info}" |
				grep -o -- ' [^ ]*TARGET[^ ]* ' |
				cut -d'=' -f 1 |
				sed 's/ //g' |
				sort |
				uniq |
				grep -Ev -- '^(AMDGPU|PYTHON|QEMU)_'
		); do
			echo "${info}" | format "${target}"
		done
		unset target
		echo
		unset info

		# shellcheck disable=SC2086
		(
			do_emerge \
					  ${parallel} \
					  ${opts} \
					--buildpkg=y \
					--usepkg=y \
					--with-bdeps=n \
					--with-bdeps-auto=n \
				-- "${package}"
		) || : $(( rc = rc + ${?} ))

		git_safedirectory_markall
		;;
	*)
		# If 'locale-gen' is initially present, then we *should* already have
		# run it... but then, we're invoking it with '--update' and so
		# re-running should be a no-op?
		#
		has_locale_gen=0
		if command -v locale-gen >/dev/null 2>&1; then
			has_locale_gen=1
		fi

		# Separate any command-line flags and packages...
		#
		flags="$( parse_opt_get_options "${@}" )"
		print "Options from '${*}' are '${flags:-}'"

		packages="$( parse_opt_get_packages "${@}" )"
		print "Package(s) from '${*}' are '${packages}'"

		# Extract first package, to pass to check() if we've built a package...
		#
		first_package="$( parse_opt_get_package "${@}" )"
		print "First package from '${*}' is '${first_package}'"
		if [ -z "${first_package:-}" ]; then
			die "Unable to identify initial package"
		fi

		# '--nodeps' should only ever be set when finalising service-builds,
		# whereas the flags required for llvm/clang/llvm-libunwind to work
		# as intended should only be needed for kernel and individual package
		# builds...
		#
		if ! echo " ${post_pkgs:-} " | grep -Fq -- ' --nodeps '; then
			post_pkgs="${post_pkgs:+"${post_pkgs} "}$( # <- Syntax
				applyworkarounds --post_pkgs "${*}"
			)"
			post_use="${post_use:+"${post_use} "}$( # <- Syntax
				applyworkarounds --post_use "${*}"
			)"
		fi  # ! echo " ${post_pkgs:-} " | grep -Fq -- ' --nodeps '

		echo
		echo " * Building requested '${packages}' package(s)" \
			"${post_pkgs:+"(with post-package list)"} ..."
		echo

		if
				[ -n "${ROOT:-}" ] && [ "${ROOT}" != '/' ] &&
				[ -n "${COLLISION_IGNORE:-}" ]
		then
			COLLISION_IGNORE="${COLLISION_IGNORE} $( # <- Syntax
				echo "${COLLISION_IGNORE}" |
					sed "s|${ROOT%"/"}||g"
			)"
		fi
		COLLISION_IGNORE="$( # <- Syntax
			echo "${COLLISION_IGNORE}" |
				xargs -r printf '%s '
		)"
		COLLISION_IGNORE="${COLLISION_IGNORE%" "}"
		export COLLISION_IGNORE

		info="$( LC_ALL='C' emerge --info --verbose=y )"
		echo
		echo "Resolved build variables for requested" \
			"packages${post_pkgs:+" (with post-package list)"}:"
		echo '-----------------------------------------------'
		echo
		echo "ROOT                = $( echo "${info}" | grep -- '^ROOT=' | cut -d'=' -f 2- )"
		echo "SYSROOT             = $( echo "${info}" | grep -- '^SYSROOT=' | cut -d'=' -f 2- )"
		echo "${info}" | format 'FEATURES'
		echo "${info}" | format 'ACCEPT_LICENSE'
		echo "${info}" | format 'USE'
		echo "${info}" | format 'COLLISION_IGNORE'
		echo "${info}" | format 'PYTHON_SINGLE_TARGET'
		echo "${info}" | format 'PYTHON_TARGETS'
		echo
		target=''
		for target in $( # <- Syntax
			echo "${info}" |
				grep -o -- ' [^ ]*TARGET[^ ]* ' |
				cut -d'=' -f 1 |
				sed 's/ //g' |
				sort |
				uniq |
				grep -Ev -- '^(AMDGPU|PYTHON|QEMU)_'
		); do
			echo "${info}" | format "${target}"
		done
		unset target
		#echo
		unset info

		# Do we want to build packages one at a time (indicated via the
		# '--single-build' flag in EMERGE_OPTS)?
		#
		if [ -n "${EMERGE_OPTS:-}" ] && echo " ${EMERGE_OPTS} " |
				grep -Eq -- ' --single(-build)? '
		then
			# ... then process any non-flag options as individual packages to
			# rebuild, except when EMERGE_OPTS contains '--swap-build', in
			# which case we instead save the first non-flag argument and come
			# back to it later...
			#
			for package in ${packages}; do
				if echo " ${EMERGE_OPTS} " |
							grep -Eq -- ' --swap(-build)? ' &&
						[ "${package}" = "${first_package}" ]
				then
					# Skip first package for now, so we can build it alone at
					# the end
					continue
				fi

				echo
				echo " * Building single package '${package}' from" \
					"'${packages}' ..."
				echo
				# shellcheck disable=SC2086
				(
					USE="$( applyworkarounds --use "${package}" "${USE}" )"
					export USE
					do_emerge \
							  ${parallel} \
							  ${opts} \
							--buildpkg=y \
							--usepkg=y \
							--with-bdeps=n \
							--with-bdeps-auto=n \
							  ${flags:-} \
						-- "${package}"
				) || : $(( rc = rc + ${?} ))
				clearworkarounds
			done
			unset package

			# ... and finally, if '--swap-build' is in effect, build the first
			# original package specified now, at the end of the process.
			#
			if echo " ${EMERGE_OPTS} " |
					grep -Eq -- ' --swap(-build)? '
			then
				echo
				echo " * Building first package '${first_package}' from" \
					"'${packages}' ..."
				echo
				# shellcheck disable=SC2086
				(
					USE="$( applyworkarounds --use "${first_package}" "${USE}" )"
					export USE
					do_emerge \
							  ${parallel} \
							  ${opts} \
							--buildpkg=y \
							--usepkg=y \
							--with-bdeps=n \
							--with-bdeps-auto=n \
							  ${flags:-} \
						-- "${first_package}"
				) || : $(( rc = rc + ${?} ))
				clearworkarounds
			fi

		else  # ! echo " ${EMERGE_OPTS:-} " | grep -Eq -- ' --single(-build)? '
			echo
			echo " * Building package(s) '${packages}' ..."
			echo

			# We're not performing single-builds, so build everything at the
			# same time (and potentially in parallel)
			#
			# shellcheck disable=SC2086
			(
#set -x
				USE="$( applyworkarounds --use "${*}" "${USE}" )"
				export USE
				print "USE flags for build are '${USE}'"
#set +x
				do_emerge \
						  ${parallel} \
						  ${opts} \
						--buildpkg=y \
						--usepkg=y \
						--with-bdeps=n \
						--with-bdeps-auto=n \
						  ${flags:-} \
					-- ${packages}
			) || : $(( rc = rc + ${?} ))
			unset packages
			clearworkarounds
		fi

		git_safedirectory_markall

		unset packages flags

		if [ -n "${rebuild:-}" ]; then

			# Separate any command-line post flags and packages...
			#
			# shellcheck disable=SC2086
			flags="$( parse_opt_get_options "${@}" ${rebuild} )"
			print "Options from '${*}${rebuild:+" ${rebuild}"}' are '${flags}'"

			# shellcheck disable=SC2086
			packages="$( parse_opt_get_packages ${rebuild} )"
			print "Package(s) from '${rebuild}' are '${packages}'"

			echo
			echo " * Rebuilding requested '${packages}'" \
				"package(s)${flags:+" with options ${flags}"} ..."
			echo

			# See handling of EMERGE_OPTS above for details of logic below, but
			# without the complexity of '--swap-build' and with the (passed-in)
			# value of $rebuid appended to the argument list...
			#
			if [ -n "${EMERGE_OPTS:-}" ] &&
					echo " ${EMERGE_OPTS} " |
						grep -Eq -- ' --single(-rebuild)? '
			then
				for package in ${packages}; do
					echo
					echo " * Building single package '${package}'" \
						"from '${packages} ..."
					echo

					# Reinstall package first to maximise dependency
					# re-use...
					#
					# shellcheck disable=SC2086
					(
						USE="$( applyworkarounds --use "${arg}" "${USE}" )"
						export USE
						do_emerge \
								  ${parallel} \
								  ${opts} \
								--buildpkg=y \
								--usepkg=y \
								--with-bdeps=y \
								  ${flags:-} \
							-- ${package}
					) || : $(( rc = rc + ${?} ))
					clearworkarounds

					git_safedirectory_markall

					# ... then install again without '--usepkg':
					#
					# shellcheck disable=SC2086
					(
						do_emerge \
								  ${parallel} \
								  ${opts} \
								--buildpkg=y \
								--usepkg=n \
								--with-bdeps=n \
								--with-bdeps-auto=n \
								  ${flags:-} \
							-- ${package}
					) || : $(( rc = rc + ${?} ))
				done
				unset package packages

			else  # [ -z "${EMERGE_OPTS:-}" ] || ! echo " ${EMERGE_OPTS} " | grep -Eq -- ' --single(-rebuild)? '; then

				# Reinstall package first to maximise dependency re-use...
				#
				# shellcheck disable=SC2086
				(
					USE="$( applyworkarounds --use "${rebuild}" "${USE}" )"
					export USE
					do_emerge \
							  ${parallel} \
							  ${opts} \
							--buildpkg=y \
							--usepkg=y \
							--with-bdeps=y \
						-- ${packages}
				) || : $(( rc = rc + ${?} ))

				git_safedirectory_markall

				# ... then install again without '--usepkg':
				#
				# shellcheck disable=SC2086
				(
					do_emerge \
							  ${parallel} \
							  ${opts} \
							--buildpkg=y \
							--usepkg=n \
							--with-bdeps=n \
							--with-bdeps-auto=n \
						-- ${packages}
				) || : $(( rc = rc + ${?} ))
				clearworkarounds
			fi

			unset packages flags
		fi  # [ -n "${rebuild:-}" ]

		if [ -n "${post_pkgs:-}" ]; then
			savefailed
			check ${rc} "${@}"

			# portage is *still* tripping over sys-devel/gcc[openmp] :(
			#
			extra_pkgs=''
			if grep -qw -- 'openmp' "${ROOT%"/"}"/var/db/pkg/*/*/USE; then
				# FIXME: Apparently we need USE-flags for app-alternatives/yacc
				# and app-alternatives/lex here too...
				post_use="${post_use:+"${post_use} "}bison flex openmp"
				extra_pkgs="$( # <- Syntax
					# dev-php/pecl-imagick requires
					# media-gfx/imagemagick[-openmp]
					#
					grep -lw -- 'openmp' "${ROOT%"/"}"/var/db/pkg/*/*/IUSE |
						rev |
						cut -d'/' -f 2-3 |
						rev |
						grep -Fv -- 'media-gfx/imagemagick' |
						sed 's/^/>=/' |
						xargs -r
				)"
			fi
			if [ -n "${extra_pkgs:-}" ]; then
				print "Adding 'openmp' USE-flag and additional packages" \
					"'${extra_pkgs}' to resolve dependency-calculation issues"
				post_pkgs="${post_pkgs:+"${post_pkgs} "}${extra_pkgs}"
			fi
			unset extra_pkgs

			[ -n "${post_use:-}" ] && export USE="${post_use}"

			# Separate any command-line post flags and packages...
			#
			# shellcheck disable=SC2086
			flags="$( parse_opt_get_options ${post_pkgs} )"
			print "Options from '${post_pkgs}' are '${flags:-}'"

			# shellcheck disable=SC2086
			packages="$( parse_opt_get_packages ${post_pkgs} )"
			print "Package(s) from '${post_pkgs}' are '${packages}'"

			echo
			echo " * Building specified post-installation '${packages}'" \
				"package(s)${flags:+" with options ${flags}"} ..."
			echo

			info="$( LC_ALL='C' emerge --info --verbose=y )"
			echo
			echo 'Resolved build variables for post-installation packages:'
			echo '-------------------------------------------------------'
			echo
			echo "ROOT                = $( # <- Syntax
				echo "${info}" | grep -- '^ROOT=' | cut -d'=' -f 2-
			)"
			echo "SYSROOT             = $( # <- Syntax
				echo "${info}" | grep -- '^SYSROOT=' | cut -d'=' -f 2-
			)"
			echo "${info}" | format 'FEATURES'
			echo "${info}" | format 'USE'
			echo "${info}" | format 'PYTHON_SINGLE_TARGET'
			echo "${info}" | format 'PYTHON_TARGETS'
			echo
			target=''
			for target in $( # <- Syntax
				echo "${info}" |
					grep -o -- ' [^ ]*TARGET[^ ]* ' |
					cut -d'=' -f 1 |
					sed 's/ //g' |
					sort |
					uniq |
					grep -Ev -- '^(AMDGPU|PYTHON|QEMU)_'
			); do
				echo "${info}" | format "${target}"
			done
			unset target
			echo
			unset info

			# Build post_pkgs one at a time, and verbosely?
			#
			#(
			#	do_emerge \
			#			  ${opts} \
			#			--jobs=1 \
			#			--quiet-build=n \
			#			--buildpkg=y \
			#			--usepkg=y \
			#			--with-bdeps=n \
			#			--with-bdeps-auto=n \
			#			  ${flags:-} \
			#		-- ${packages}
			#) || : $(( rc = rc + ${?} ))

			# In case we're building with --nodeps, extract acct-* packages
			# first...
			#
			if echo "${packages}" | grep -q -- 'acct-'; then
				post_acct_pkgs="$( # <- Syntax
					echo "${packages}" |
						xargs -rn 1 |
						grep -- '^acct-' |
						sort |
						xargs -r
				)"
				if [ -n "${post_acct_pkgs:-}" ]; then
					echo
					echo " * Building specified post-installation" \
						"'${post_acct_pkgs}' account packages ..."
					echo

					# We don't want any provided flags to apply to account
					# packages...
					#
					# shellcheck disable=SC2086
					(
						do_emerge \
								  ${parallel} \
								  ${opts} \
								--buildpkg=y \
								--usepkg=y \
								--with-bdeps=n \
								--with-bdeps-auto=n \
							-- ${post_acct_pkgs}
					) || : $(( rc = rc + ${?} ))
				fi  # [ -n "${post_acct_pkgs:-}" ]

				packages="$( # <- Syntax
					echo "${packages}" |
						xargs -rn 1 |
						grep -v -- '^acct-' |
						xargs -r
				)"
			fi  # echo "${post_pkgs}" | grep -q -- 'acct-'

			gcc_exclude=''

			# First build any post_pkgs which will be installed without
			# dependencies on the base-system, to ensure that the right binary
			# package is available to the ROOT installation...
			#
			if echo " ${flags:-} " | grep -q -- '\s--nodeps\s'; then
				echo
				echo " * Building specified post-installation '${packages}'" \
					"package(s) into installation root '/' ..."
				echo
				# shellcheck disable=SC2046,SC2086
				(
					flags="$( echo " ${flags} " | sed 's/\s--nodeps\s/ /g' )"
					# FIXME: We somehow need USE='flex' by the time we reach
					#        here?
					USE="$( echo " flex ${USE:-} " | sed 's/\slib-only\s/ /g' )"
					export flags USE
					export ROOT='/' SYSROOT='/' PORTAGE_CONFIGROOT='/'
					do_emerge \
							  ${parallel} \
							  ${opts} \
							--buildpkg=y \
							--usepkg=y \
							--with-bdeps=y \
							--with-bdeps-auto=y \
							  ${flags:-} \
						-- ${packages}
				) || : $(( rc = rc + ${?} ))
			fi  # echo " ${flags:-} " | grep -q -- '\s--nodeps\s'

			git_safedirectory_markall

			if echo " ${packages} " |
						grep -Eq -- '\s([<>]?=?sys-devel/)?gcc([-:][^\s]+)?\s' ||
					echo " ${USE} " |
						grep -q -- ' lib-only '
			then
				gcc_exclude='--exclude=sys-devel/gcc'
			fi

			echo
			echo " * Building specified post-installation '${packages}'" \
				"package(s) into installation root '${ROOT}' ..."
			echo
			# shellcheck disable=SC2086
			(
				USE="$( echo " ${USE:-} " | sed 's/\slib-only\s/ /g' )"
				export USE
				do_emerge \
						  ${parallel} \
						  ${opts} \
						--buildpkg=y \
						  ${gcc_exclude:-} \
						--oneshot \
						--usepkg=y \
						--with-bdeps=n \
						--with-bdeps-auto=n \
						  ${flags:-} \
					-- ${packages}
			) || : $(( rc = rc + ${?} ))

			if [ -n "${gcc_exclude:-}" ]; then
				gcc_pkgs="$( # <- Syntax
					echo " ${packages} " |
						grep -Eo -- '\s([<>]?=?sys-devel/)?gcc(-config)?([-:][^\s]+)?\s' |
						awk '{ print $1 }' |
						xargs -rn 1 |
						sort |
						uniq |
						grep -Fv -- 'gcc-config' |
						xargs -r
				)"
				if [ -n "${gcc_pkgs:-}" ]; then
					# FIXME: If we're building with '--nodeps' (to avoid
					# unnecessary 'lib-only' dependencies) but we don't have a
					# pre-exising binary package, then we need sys-devel/gcc
					# BDEPEND packages to be present...
					#
					gcc_build_pkgs="app-portage/elt-patches sys-apps/texinfo sys-devel/flex sys-devel/m4"
					echo
					echo " * Building post-installation '${gcc_pkgs}" \
						"${gcc_build_pkgs}' package(s) into installation" \
						"root '${ROOT}' ..."
					echo
					# shellcheck disable=SC2086
					(
						do_emerge \
								  ${opts} \
								  ${parallel} \
								--buildpkg=y \
								--nodeps \
								--oneshot \
								--usepkg=y \
								--with-bdeps-auto=n \
								--with-bdeps=n \
								  ${flags:-} \
							-- ${gcc_pkgs} ${gcc_build_pkgs}
					) || : $(( rc = rc + ${?} ))

					[ "${intent:-}" = 'keep' ] &&
						pkg_remove 'post-installation' ${gcc_build_pkgs}
				fi  # [ -n "${gcc_pkgs:-}" ]
				unset gcc_build_pkgs gcc_pkgs
			fi  # [ -n "${gcc_exclude:-}" ] && echo "${post_pkgs}" | grep -Fq -- 'gcc'

			unset gcc_exclude packages flags
		fi  # [ -n "${post_pkgs:-}" ]

		if [ $(( has_locale_gen )) -eq 0 ]; then
			do_locale_gen
		fi
		;;
esac

# We only reach here if we built a package above...
#

savefailed
check ${rc} "${first_package}"

if [ -n "${post_remove:-}" ] && [ "${intent:-}" = 'keep' ]; then
	pkg_remove 'post-installation' "${post_remove}"
fi

if [ $(( depclean )) -ne 0 ]; then
	echo
	echo " * Running 'depclean' against ROOT '${ROOT:-"/"}' ..."

	mkdir -p /etc/portage/profile
	if [ -s /etc/portage/profile/package.provided ]; then
		mv /etc/portage/profile/package.provided \
			/etc/portage/profile/package.provided.backup
	fi

	# This list must be kept in sync with sys-devel/gcc dependencies!
	#
	cat >> /etc/portage/profile/package.provided <<-EOF
		dev-libs/gmp-6.3.0-r1
		dev-libs/mpc-1.3.1
		dev-libs/mpfr-4.2.1
		sys-devel/gcc-config-2.11
	EOF

	# 'emerge --exclude' has unhelpful syntax requirements in that it won't
	# accept initial comparators or versions, so we need to strip these in a
	# sensible way <sigh>.
	#
	# We're also unable to use the (bash) functions from eapi7-ver.eclass in
	# this (POSIX sh) script.
	#
	# ... so let's just do the best we can.
	#
	filtered_depclean_exclude=''
	for arg in ${depclean_exclude:-}; do
		filtered_depclean_exclude="${filtered_depclean_exclude:+"${filtered_depclean_exclude} "}$( # <- Syntax
			echo "${arg}" |
				sed 's/^[<>]\?=\?// ; s/-[0-9].*$// ; s/::.*$//'
		)"
	done
	unset arg
	depclean_exclude='sys-apps/busybox sys-apps/gentoo-functions sys-apps/grep'
	[ -n "${filtered_depclean_exclude:-}" ] &&
		depclean_exclude="${depclean_exclude} ${filtered_depclean_exclude}"
	filtered_depclean_exclude=''
	for arg in ${depclean_exclude}; do
		if echo "${filtered_depclean_exclude:-}" | grep -Fq -- " \?--exclude=${arg} \?"; then
			print "depclean_exclude item '${arg}' included multiple times"
		else
			filtered_depclean_exclude="${filtered_depclean_exclude:+"${filtered_depclean_exclude} "}--exclude=${arg}"
		fi
	done
	unset arg
	[ -n "${filtered_depclean_exclude:-}" ] &&
		depclean_exclude="${filtered_depclean_exclude}"
	unset filtered_depclean_exclude

	# FIXME: This may be overkill, but some containers which don't use perl
	# seem to have it pulled-in regardless...
	#
	# ...and we're still getting some build-time dependencies retained...
	#
	# shellcheck disable=SC2046
	(
		#do_emerge \
		#		--depclean \
		#		  ${depclean_exclude} \
		#		--verbose=y \
		#		--with-bdeps=n \
		pkg_remove 'final' \
			${depclean_exclude:-} \
			-- $( # <- Syntax
				echo "${first_package} ${post_pkgs}" |
						grep -Fq -- 'dev-lang/perl' ||
					echo "dev-lang/perl"
			) 'perl-core/*' 'virtual/perl-*' \
			app-alternatives/yacc sys-devel/bison \
			app-alternatives/awk sys-apps/gawk \
			app-alternatives/gzip app-arch/gzip \
			sys-apps/grep \
			dev-libs/isl \
			dev-libs/gmp dev-libs/mpc dev-libs/mpfr sys-devel/gcc-config
	) || :

	if [ -n "${depclean_extra:-}" ]; then
		if echo " ${depclean_extra:-} " |
				grep -Eq -- ' (sys-apps/)?(busybox|gentoo-functions) '
		then
			warn "Unable to depclean essential system packages" \
				"'sys-apps/busybox' or 'sys-apps/gentoo-functions'"
		fi
		# shellcheck disable=SC2086
		(
			#do_emerge \
			#		--depclean \
			#		--exclude="sys-apps/busybox sys-apps/gentoo-functions" \
			#		--verbose=y \
			#		--with-bdeps=n \
			pkg_remove 'final extra' \
				--exclude=sys-apps/busybox \
				--exclude=sys-apps/gentoo-functions \
				-- ${depclean_extra}
		) || :
	fi
	(
		#do_emerge \
		#	--depclean \
		#	--exclude=dev-libs/libffi \
		#	${depclean_exclude:-} \
		#	--verbose=y \
		#	--with-bdeps=n
		pkg_remove 'last' \
			--exclude=dev-libs/libffi \
			${depclean_exclude:-}
	) || :

	if [ -s /etc/portage/profile/package.provided.backup ]; then
		mv /etc/portage/profile/package.provided.backup \
			/etc/portage/profile/package.provided
	elif [ -e /etc/portage/profile/package.provided ]; then
		rm /etc/portage/profile/package.provided
	fi

	rmdir --ignore-fail-on-non-empty /etc/portage/profile
fi

#do_prelink

if [ -d "${ROOT}"/usr/lib/gcc ]; then
	if ! [ -d "${ROOT}/usr/lib/gcc/${CHOST:-"__chost_not_set__"}" ]; then
		warn "Directory '${ROOT}/usr/lib/gcc' exists but" \
			"'${ROOT}/usr/lib/gcc/${CHOST:-"__chost_not_set__"}' doesn't"
		print "$( ls -1AF "${ROOT}/usr/lib/gcc" )"
	else
		if ! grep -Fqm 1 -- '/gcc/' "${ROOT}/etc/ld.so.conf"; then
			find "${ROOT}/usr/lib/gcc/${CHOST:-"__chost_not_set__"}" \
						-mindepth 1 \
						-maxdepth 1 \
						-type d \
					-print0 |
				xargs -0rn 1 |
				sed "s|^${ROOT}||" >> "${ROOT}/etc/ld.so.conf"
			ldconfig ${ROOT:+"-r"} ${ROOT:+"${ROOT}"} \
				-f "${ROOT:-}/etc/ld.so.conf"
		fi
	fi
fi

find /var/db/pkg/ -mindepth 2 -maxdepth 2 -type d -print |
	sed 's|^.*/var/db/pkg/||' > /builddeps.txt

if [ -n "${ROOT:-}" ] && [ "${ROOT:-}" != '/' ]; then
	find "${ROOT}/var/db/pkg/" -mindepth 2 -maxdepth 2 -type d -print |
		sed 's|^.*/var/db/pkg/||' > "${ROOT:-}"/builddeps.txt
fi

if command -v eselect >/dev/null 2>&1; then
	# Avoid, e.g. '!!! Warning: News item "2021-07-20-perl-5_34-upgrade" no longer exists'
	eselect news read new 2>&1 |
		grep -Fv \
				-e 'No news is good news.' \
				-e '!!! Warning: News item "' \
			|| :
fi

[ $(( rc )) -eq 0 ] && emerge --moo

exit ${rc}

#[ -n "${trace:-}" ] && set +o xtrace

# vi: set colorcolumn=80 foldmarker=()\ {,}\ \ #\  foldmethod=marker syntax=sh sw=4 ts=4:
