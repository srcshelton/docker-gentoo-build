#! /usr/bin/env bash

set -eu
set -o pipefail

trace="${TRACE:-}"
debug="${DEBUG:-}"
# With 'debug' enabled, set 'DEBUG_EXTRA_ARGS' to pass additional arguments
# to 'podman build'...
#DEBUG_EXTRA_ARGS=''

#inherit python_target_override

if [[ -n "${BASH_VERSINFO[0]:-}" ]] && (( BASH_VERSINFO[0] < 4 )); then
	echo >&2 "FATAL: bash-4.0.0 or later is required to run this script - on" \
		"macOS, try 'brew install bash'"
	exit 1
fi

if [[ "$( uname -s )" == 'Darwin' ]]; then
	readlink() {
		perl -MCwd -le 'print Cwd::abs_path shift' "${2}"
	}  # readlink
fi
cd "$( dirname "$( readlink -e "${0}" )" )" || exit 1

# Support 'core' user for podman+machine Fedora default user...
if [[ "$( uname -s )" == 'Darwin' ]]; then
	if (( EUID )) && [[ "$( id -nu )" == 'core' ]]; then
		die "Please re-run '$( basename "${0}" )' as user 'root'"
	fi
fi

if [[ -n "${python_target_override:-}" ]]; then
	[[ "${python_target_override}" =~ ^python[[:digit:]]_[[:digit:]]+$ ]] ||
		die "python_target_override value '${python_target_override}'" \
			"doesn't appear to be a valid python version" \
			"(matching 'pythonX_Y', e.g. 'python3_10')"
fi

declare -i NOTIFY_MKDIR=0

# Set by common/vars.sh
declare docker='docker'
declare env_name=''
declare stage3_name=''
declare init_name=''
declare base_name=''
declare build_name=''
declare environment_filter=''
declare bold=''
declare red=''
declare blue=''
#declare purple=''
declare reset=''

# Set by common/run.sh docker_setup()
declare docker_arch=''
declare arch=''

declare native=''
declare -i build_helper=0
declare -i force=0

# use_pypy & use_pypy_use are defined in common/vars.sh
declare use_pypy_pre=''
declare use_pypy_pre_use=''
declare use_pypy_post=''
declare use_pypy_post_remove=''

# shellcheck disable=SC1091
[[ ! -s common/vars.sh ]] || . common/vars.sh

if ! $docker --version >/dev/null 2>&1; then
	die "'$docker' failed to execute: ${?}"
elif ! $docker image build --help | grep -Fq -- '--platform'; then
	die "'$docker image build' lacks '--platform' support (try podman-3.x or" \
		"later)"
fi

[[ -n "${base_dir:-}" ]]
[[ -d "${base_dir}" ]]
[[ -e "${base_dir}"/Dockerfile.env ]]
[[ -e "${base_dir}"/Dockerfile.init ]]
[[ -e "${base_dir}"/Dockerfile.build ]]

# shellcheck disable=SC2034
IMAGE="${base_name}:latest"
# shellcheck disable=SC1091
[[ -s common/run.sh ]] && . common/run.sh

if
	[[ -z "${env_name:-}" ]] ||
	[[ -z "${stage3_name:-}" ]] ||
	[[ -z "${init_name:-}" ]] ||
	[[ -z "${base_name:-}" ]] ||
	[[ -z "${build_name:-}" ]]
then
	die "Image names not correctly set in '$( pwd )/common/vars.sh'"
fi

if [[ -n "${*:-}" ]]; then
	if grep -Eq -- ' -(h|-help) ' <<<" ${*} "; then
		output >&2 "Usage: $( basename "${0}" ) [--env] [--stage3] [--init]" \
			"[[--force] --base] [[--force] --build] [[--force] --helper]"
		exit 0
	elif
		! grep -Eq -- '^(\s*--(env|stage3|init|base|build|helper|force|force-helper)\s*){1,7}$' <<<"${*}"
	then
		die "Unknown args '${*}'"
	fi

	if grep -Fq -- ' --force ' <<<" ${*} "; then
		if ! grep -Eq -- ' --(base|build|helper) ' <<<" ${*} "; then
			die "'--force' is only valid with '--base', '--build', or" \
				"'--helper'"
		fi
	fi
fi

declare -a args=()
for arg in "${@:-}"; do
	case "${arg:-}" in
		*helper)
			build_helper=1
			;;
		--force)
			force=1
			;;
		*)
			args+=( "${arg}" )
			;;
	esac
done
set -- "${args[@]:-}"
unset args arg

docker_setup

[[ -d log ]] || mkdir -p log
pushd "${base_dir}" >/dev/null 2>&1 ||
	die "chdir() to '${base_dir}' failed; ${?}"

checkids() {
	local name="${1:-}"
	local tag="${2:-}"

	#inherit docker stage3_name env_id bold reset red
	local repo='' images='' stage3_env_id='' stage3_src_id=''

	if [[ -z "${name:-}" ]]; then
		error "Image name not set"
		return 1
	fi
	if false \
		|| [[ -z "${docker:-}" ]] \
		|| [[ -z "${stage3_name:-}" ]] \
		|| [[ -z "${env_id:-}" ]] \

	then
		error "Required global variable not set"
		return 1
	fi

	local relation="inherited by"
	if [[ "${name#*/}" == "${stage3_name#*/}" ]]; then
		relation="about to be linked to"
	fi

	repo='localhost/'
	if [[ "${name}" =~ / ]]; then
		repo=''
	fi
	images="$( $docker image ls --noheading \
		"${repo}${name}:${tag:-latest}" 2>/dev/null
	)"
	if grep -Eq -- "^(localhost/)?${name}" <<<"${images}"; then
		stage3_env_id="$(
			$docker image inspect \
					--format='{{.Config.Labels.envrionment_from}}' \
				"${repo}${stage3_name}:${tag:-latest}" 2>/dev/null
		)" || :
		stage3_env_id="$( echo "${stage3_env_id:-}" | cut -d':' -f 2- )"

		# Does our current 'gentoo-env' ID match that encoded in our stage3?
		if [[ "${env_id}" != "${stage3_env_id:-}" ]]; then
			output >&2 "${bold:-}WARN${reset:-}:  ${red:-}" \
				"The current 'environment' image (${env_id}) differs from" \
				"that used to build the '${name}' image (${stage3_env_id:-})" \
				"${relation} this stage${reset:-}"
		fi

		if [[ -n "${stage3_id:-}" ]]; then
			stage3_src_id="$(
				$docker image inspect \
						--format='{{.Config.Labels.stage3_from}}' \
					"${repo}${name}:${tag:-latest}" 2>/dev/null
			)" || :
			stage3_src_id="$(
				echo "${stage3_src_id:-}" |
				awk -F':' '{ print $NF }'
			)"

			# Does our upstream stage3 ID match that encoded in our stage3?
			if [[ "${stage3_id}" != "${stage3_src_id:-}" ]]; then
				output >&2 "${bold:-}WARN${reset:-}:  ${red:-}" \
					"The upstream 'stage3' image (${stage3_id}) differs from" \
					"that used to build the '${name}' image" \
					"(${stage3_src_id:-}) ${relation} this stage${reset}"
			fi
		fi
	fi

	# This is a warning rather than an error, so...
	return 0
}  # checkids

makedir() {
	local dir="${1:-}"

	[[ -n "${dir}" ]] || return 1

	if ! (( NOTIFY_MKDIR )) && (( EUID )); then
		NOTIFY_MKDIR=1

		info "In order to run on a non-gentoo system, we need to create" \
			"several system"
		info "directories."
		info "You may be now prompted to enter your password in order to" \
			"authenticate"
		info "with superuser credentials and allow for this to proceed:"
	fi

	if [[ "$( uname -s )" == 'Darwin' ]] || (( EUID )); then
		sudo mkdir -pm 0755 "${dir}" || die "mkdir() on '${dir}' failed: ${?}"
		sudo chown ${EUID} "${dir}" || die "chown() on '${dir}' failed: ${?}"
	else
		mkdir -p "${dir}" || die "mkdir() on '${dir}' failed: ${?}"
	fi

	info " * ${dir}"
}  # makedir

# Check for environment sanity...
if ! command -v portageq >/dev/null 2>&1; then
	warn "Not running on Gentoo host system, not checking eclass overrides"

	# shellcheck disable=SC2043
	for dir in /etc/portage/repos.conf; do
		[[ -d "${dir}" ]] || makedir "${dir}"
	done
	unset dir
	for cfg in DEFAULT.conf gentoo.conf srcshelton.conf; do
		[[ -s /etc/portage/repos.conf/${cfg} ]] ||
			cp -v etc/portage/repos.conf/${cfg} /etc/portage/repos.conf/
	done
	unset cfg

	declare -i private_gentoo_clone=0
	declare repo_path_gentoo='/var/db/repo/gentoo'
	declare repo_path_srcshelton='/var/db/repo/srcshelton'

	# FIXME: Hardcoded paths, use repos.conf
	if [[ ! -d "${repo_path_gentoo}" ]] && [[ ! -d /var/db/repos/gentoo ]]; then
		# macOS 'df' lacks the below options
		if [[ "$( uname -s )" != 'Darwin' ]]; then
			for dir in /var/db/repo{,s} /var/db; do
				if [[ -d "${dir}" ]]; then
					# FIXME: Figure out best macOS implementation
					if (( $(
						df --block-size=1G --output=avail "${dir}" |
						tail -n 1
					) < 2 )); then
						die "Insufficient filesystem space to download" \
							"Gentoo Portage repo: 2GB required"
					fi
					break
				fi
			done
			unset dir
		fi

		command -v git >/dev/null 2>&1 || die "required binary 'git' missing"

		note "Creating local Gentoo Portage repo mirror at" \
			"'${repo_path_gentoo}' ..."

		# shellcheck disable=SC2043,SC2066
		for dir in "$( dirname "${repo_path_gentoo}" )"; do
			[[ -d "${dir}" ]] || makedir "${dir}"
		done
		unset dir

		git clone https://github.com/gentoo/gentoo.git "${repo_path_gentoo}" ||
			die "git 'clone' operation failed: ${?}"

		private_gentoo_clone=1

	elif [[ -d /var/db/repos/gentoo ]]; then
		repo_path_gentoo='/var/db/repos/gentoo'
	fi

	if [[ ! -d "${repo_path_srcshelton}" ]] && [[ ! -d /var/db/repos/srcshelton ]]; then
		command -v git >/dev/null 2>&1 || die "required binary 'git' missing"

		note "Creating custom packages repo mirror at" \
			"'${repo_path_srcshelton}' ..."

		# shellcheck disable=SC2043,SC2066
		for dir in "$( dirname "${repo_path_srcshelton}" )"; do
			[[ -d "${dir}" ]] || makedir "${dir}"
		done
		unset dir

		git clone \
				https://github.com/srcshelton/gentoo-ebuilds.git \
				"${repo_path_srcshelton}" ||
			die "git 'clone' operation failed: ${?}"

	elif [[ -d /var/db/repos/srcshelton ]]; then
		repo_path_srcshelton='/var/db/repos/srcshelton'
	fi

	declare ref=''
	if
		[[ -s "${repo_path_srcshelton}/.portage_commit" ]] &&
		ref="$( < "${repo_path_srcshelton}/.portage_commit" )" &&
		[[ -n "${ref:-}" ]]
	then
		pushd "${repo_path_gentoo}" >/dev/null 2>&1
		declare head=''
		head="$( git rev-parse HEAD )"
		if [[ "${ref}" == "${head:-}" ]]; then
			note "Local Gentoo Portage repo mirror is in sync with custom" \
				"packages repo at commit '${ref:0:7}'"
		elif git rev-parse -q --verify "${ref}^{commit}" >/dev/null 2>&1; then
			info "Local Gentoo Portage repo mirror is currently at commit" \
				"'${head:0:7}' but can be reverted to custom packages repo" \
				"target commit '${ref:0:7}'"
			if (( private_gentoo_clone )); then
				if git reset --hard "${ref}"; then
					info "Local Gentoo Portage repo mirror is now in sync" \
						"with custom packages repo at commit '${ref:0:7}'"
				else
					error "Unable to reset local Gentoo Portage repo mirror" \
						"to commit '${ref:0:7}': ${?}"
				fi
			else
				warn "Not changing local Gentoo Portage repo mirror contents" \
					"for potentailly shared clone"
			fi
		else
			error "Custom packages target commit '${ref:0:7}' does not exist" \
				"in local Gentoo Portage repo mirror - mirror out of date?"
		fi
		unset head
		popd >/dev/null 2>&1
	fi
	unset ref

	for dir in /var/cache/portage/dist /var/log/portage /var/cache/portage/pkg; do
		[[ -d "${dir}" ]] || makedir "${dir}"
	done
	unset dir

	unset private_gentoo_clone repo_path_gentoo repo_path_srcshelton

	# Flags may have changed...
	# shellcheck disable=SC1091
	[[ ! -s common/vars.sh ]] || . common/vars.sh

else # command -v portageq >/dev/null 2>&1; then

	declare -i rc=0

	while read -r repo; do
		# FIXME: Discover default rather than assuming 'gentoo'?
		[[ "${repo}" == 'gentoo' ]] && continue

		while read -r dir; do
			if [[ -d "${dir}"/eclass ]]; then
				grep -hR eclass /etc/portage/repos.conf |
						sed 's/#.*//' |
						grep '^eclass-overrides' |
						cut -d '=' -f 2- |
						grep -Fqw -- "${repo}" &&
					continue
				warn "ebuild repo '${repo}' contains class overrides, but" \
					"portage isn't configured to allow their use"
				warn "Add/update 'eclass-overrides = ${repo}' in" \
					"/etc/portage/repos.conf"
				rc=1
			fi
		done < <( portageq get_repo_path "${EROOT:-/}" "${repo}" )
		unset dir

	done < <( portageq get_repos "${EROOT:-/}" | xargs -n 1 )
	unset repo

	(( rc )) && sleep 5

	# FIXME: Discover default rather than assuming 'gentoo'?
	declare repo_path_gentoo=''
	declare repo_path_srcshelton=''
	declare ref=''
	repo_path_gentoo="$(
		portageq get_repo_path "${EROOT:-/}" 'gentoo' >/dev/null 2>&1
	)"
	repo_path_srcshelton="$(
		portageq get_repo_path "${EROOT:-/}" 'srcshelton' >/dev/null 2>&1
	)"
	if
		[[ -n "${repo_path_gentoo:-}" && -d "${repo_path_gentoo}" ]] &&
		[[ -n "${repo_path_srcshelton:-}" && -d "${repo_path_srcshelton}" ]] &&
		[[ -s "${repo_path_srcshelton}/.portage_commit" ]] &&
		ref="$( < "${repo_path_srcshelton}/.portage_commit" )" &&
		[[ -n "${ref:-}" ]]
	then
		pushd "${repo_path_gentoo}" >/dev/null 2>&1
		declare head=''
		head="$( git rev-parse HEAD )"
		if [[ "${ref}" == "${head:-}" ]]; then
			note "Local Gentoo Portage repo mirror is in sync with custom" \
				"packages repo at commit '${ref:0:7}'"
		elif git rev-parse -q --verify "${ref}^{commit}" >/dev/null 2>&1; then
			warn "Local Gentoo Portage repo mirror is currently at commit" \
				"'${head:0:7}' but can be reverted to custom packages repo" \
				"target commit '${ref:0:7}'"
		else
			error "Custom packages target commit '${ref:0:7}' does not exist" \
				"in local Gentoo Portage repo mirror - mirror out of date?"
		fi
		unset head
		popd >/dev/null 2>&1
	fi
	unset ref repo_path_srcshelton repo_path_gentoo
fi

# 'cut' separately to emulate 'pipefail' when using /bin/sh
#
# (... which we aren't any longer - but pipefail does seem to cause some
# unexpected behaviour)
#
declare sum=''
sum="$( sha1sum entrypoint.sh )"
sum="$( echo "${sum}" | cut -d' ' -f 1 )"

stage3_tag='latest'
# https://hub.docker.com/r/gentoo/stage3 tag-naming is a mess - not only does
# it keep changing, but there's now an inconsistency as to whether the init
# system is tagged onto the image or not (for example, the amd64 image used to
# be 'amd64-nomultilib', which is now no longer being updated.  There are now
# new 'nomultilib' and 'amd64-nomultilib-openrc' images - while the 32bit image
# name has changed from 'x86' to 'i686-openrc' and the ARM image names are
# unchanged in the case of 'openrc' but now also have variants with a 'systemd'
# suffix)
case "${docker_arch}" in
	'amd64')
		stage3_tag="${docker_arch}-nomultilib-openrc" ;;
	'arm64')
		stage3_tag="${docker_arch}" ;;
	'arm/v7')
		stage3_tag='armv7a_hardfp' ;;
	'arm/v6')
		stage3_tag='armv6j_hardfp' ;;
	'i386')
		stage3_tag='i686-openrc' ;;
esac
case "${docker_arch}" in
	'arm'*)
		# See https://community.arm.com/developer/tools-software/tools/b/tools-software-ides-blog/posts/compiler-flags-across-architectures-march-mtune-and-mcpu
		native='-mcpu=native' ;;
esac
env_id="$(
	$docker image ls --noheading \
			--format='{{.ID}}' \
		"${env_name}:latest" 2>/dev/null
)" || :
local_stage3_id="$(
	$docker image ls --noheading \
			--format='{{.ID}}' \
		"${stage3_name}:latest" 2>/dev/null
)" || :

[[ -n "${trace:-}" ]] && set -o xtrace

# Create empty stage with shared environment variables ...
#
if [[ -z "${*:-}" ]] || grep -Fq -- ' --env ' <<<" ${*} "; then
	output
	output " ${blue}*${reset} Creating image '${env_name}:latest' ..."
	output

	# NAME:    env
	# LABELS:
	# USES:
	# USED_BY: stage3 build

	# shellcheck disable=SC2086
	$docker image build \
			--platform "linux/${docker_arch}" \
			--build-arg ARCH="${arch}" \
			--build-arg PROFILE_PATH="${profile:-}" \
			--build-arg CHOST="${chost:-}" \
			${use_cpu_arch:+${use_cpu_flags_raw:+--build-arg CPU_FLAGS_${use_cpu_arch^^}="${use_cpu_flags_raw}"}} \
			${native:+--build-arg NATIVE="${native}"} \
			--build-arg JOBS="${JOBS:-}" \
			--build-arg MAXLOAD="${MAXLOAD:-}" \
			--build-arg MAIL_FROM="${mail_from:-}" \
			--build-arg MAIL_TO="${mail_to:-}" \
			--build-arg MAIL_MTA="${mail_mta:-}" \
			--build-arg SET_TERM="${TERM:-}" \
			--build-arg SET_USE_ESSENTIAL="${use_essential:-}" \
			--build-arg SET_USE_ESSENTIAL_GCC="${use_essential_gcc:-}" \
			--compress \
			--file 'Dockerfile.env' \
			${debug:+--loglevel 3 ${DEBUG_EXTRA_ARGS:-}} \
			--network none \
			--no-cache \
			--tag "${env_name}:latest" \
			--rm \
		. 2>&1 | tee ../log/"docker.${env_name#*/}.log"
	output " -> ${?}"

	[[ "${*:-}" = '--env' ]] && exit 0

	env_id="$( $docker image ls --noheading \
			--format='{{.ID}}' \
		"${env_name}:latest" 2>/dev/null
	)"

	output
	output " ${blue}*${reset} Stage 'env' complete, next is 'stage3' ..."
	output
fi

stage3_image="$(
	grep -- '^ARG stage3_image=' Dockerfile.stage3 |
	cut -d'"' -f 2
)"

if [[ -z "${*:-}" ]] || grep -Fq -- ' --stage3 ' <<<" ${*} "; then
	if [[ -z "${env_id:-}" ]]; then
		die "Environment stage not found - please run" \
			"'$( basename "${0}" ) --env'"
	fi

	output
	output " ${blue}*${reset} Creating image" \
		"'${stage3_name}:latest' ..."
	output

	# We have to 'pull' manually, or else this stage fails ...
	rc=0
	trap '' INT
	if [[ "${stage3_tag}" = 'latest' ]]; then
		if
			$docker image pull --help |
				grep -Fq -- '--platform'
		then
			$docker image pull "${stage3_image}:latest" \
					--platform "linux/${docker_arch}"
		elif
			$docker image pull --help |
				grep -Fq -- '--override-arch'
		then
			$docker image pull "${stage3_image}:latest" \
					--override-arch "${docker_arch}"
		elif
			$docker image pull --help |
				grep -Fq -- '--arch'
		then
			$docker image pull "${stage3_image}:latest" \
					--arch "${docker_arch}"
		else
			die "Could not determine method to retrieve" \
				"non-native architecture with" \
				"'$docker image pull'"
		fi
	else
		$docker image pull "${stage3_image}:${stage3_tag}" || rc=${?}
	fi
	trap - INT
	[[ $(( rc )) -eq 0 ]] ||
		die "'$docker image pull' failed to retrieve image '${stage3_image}:latest' for architecture '${docker_arch}'"
	stage3_id="$(
		$docker image ls --noheading \
				--format='{{.ID}}' \
			"${stage3_image}:${stage3_tag}" 2>/dev/null
	)" || :

	# NAME:    stage3
	# LABELS:  envrionment_from stage3_from
	# USES:    [gentoo/stage3-amd64] env
	# USED_BY: init

	# shellcheck disable=SC2086
	$docker image build \
			--platform "linux/${docker_arch}" \
			--build-arg ARCH="${arch}" \
			--build-arg env_id="${env_id}" \
			--build-arg env_name="${env_name}" \
			--build-arg stage3_id="${stage3_id}" \
			--build-arg stage3_image="${stage3_image}" \
			--build-arg stage3_tag="${stage3_tag}" \
			${python_target_override:+--build-arg python_target_override="${python_target_override}"} \
			--compress \
			--file 'Dockerfile.stage3' \
			${debug:+--loglevel 3 ${DEBUG_EXTRA_ARGS:-}} \
			--network none \
			--no-cache \
			--tag "${stage3_name}:latest" \
		. 2>&1 | tee ../log/"docker.${stage3_name#*/}.log"
	output " -> ${?}"

	[[ "${*:-}" == '--stage3' ]] && exit 0

	local_stage3_id="$(
		$docker image ls --noheading \
				--format='{{.ID}}' \
			"${stage3_name}:latest" 2>/dev/null
	)"

	output
	output " ${blue}*${reset} Stage 'stage3' complete, next is 'init' ..."
	output
else
	stage3_id="$(
		$docker image ls --noheading \
				--format='{{.ID}}' \
			"${stage3_image}:${stage3_tag}" 2>/dev/null
	)" || :
fi

# Create initial image from Gentoo stage3 ...
#
# N.B. The first block below is executed if we DON'T have '--init' as an
#      argument, but may clear the command-line parameters so that the 'init'
#      block below that IS executed.
#
if [[ -n "${*:-}" ]] && ! grep -Fq -- ' --init ' <<<" ${*} "; then
	# Executed individually, `$docker image ls` and `grep` both succeed.
	# With 'pipefail' disabled, the following test does the right thing.
	# However, with pipefail set the statement is interpreted to have
	# failed when run in the same pipeline?!
	#
	images="$(
		$docker image ls --noheading \
			"${init_name}" 2>/dev/null
	)"
	if grep -Eq -- "^(localhost/)?${init_name}" <<<"${images}"; then
		imagesum="$(
			$docker image inspect \
					--format='{{.Config.Labels.entrypoint_sum}}' \
				"${init_name}:latest" 2>/dev/null
		)" || :
		if [[ "${imagesum:-}" != "${sum}" ]]; then
			if (( force )); then
				output >&2
				output >&2 "${bold}WARN${reset}:  ${red}'entrypoint.sh'" \
					"checksum from '${init_name}:latest' image" \
					"(${imagesum:-<unknown>}) does not match file on disk" \
					"(${sum}) - forcing continuation with existing embedded" \
					"script ...${reset}"
			else
				output >&2
				output >&2 "${bold}WARN${reset}:  ${red}'entrypoint.sh'" \
					"checksum from '${init_name}:latest' image" \
					"(${imagesum:-<unknown>}) does not match file on disk" \
					"(${sum}) - rebuilding initial image ...${reset}"
				set --
			fi
		fi
	else
		output >&2 "docker image '${init_name}' not found - rebuilding initial" \
			"image ..."
		set --
	fi
fi

if [[ -z "${*:-}" ]] || grep -Fq -- ' --init ' <<<" ${*} "; then
	if [[ -z "${local_stage3_id:-}" ]]; then
		die "Updated Gentoo stage 3 image '${stage3_name}:latest'" \
			"not found - please execute '$(
				basename "${0}"
			) --stage3'"
	fi

	output
	output " ${blue}*${reset} Creating image '${init_name}:latest' ..."
	output

	checkids "${stage3_name}"

	# NAME:    init
	# LABELS:  stage3_from entrypoint_sum
	# USES:    stage3
	# USED_BY: base

	# shellcheck disable=SC2086
	$docker image build \
			--platform "linux/${docker_arch}" \
			--build-arg ARCH="${arch}" \
			--build-arg entrypoint_sum="${sum}" \
			--build-arg environment_filter="${environment_filter}" \
			--build-arg stage3_id="${stage3_id}" \
			--build-arg stage3_image="${stage3_image}:${stage3_tag}" \
			--compress \
			--file 'Dockerfile.init' \
			${debug:+--loglevel 3 ${DEBUG_EXTRA_ARGS:-}} \
			--network none \
			--no-cache \
			--tag "${init_name}:latest" \
		. 2>&1 | tee ../log/"docker.${init_name#*/}.log"
			#--network slirp4netns \
	output " -> ${?}"

	output
	output " ${blue}*${reset} Stage 'init' complete, next is 'base' ..."
	output
else
	checkids "${stage3_name}"
fi

# Launch initial image and run entrypoint script to install root @system, then
# snapshot the result to create a base image ...
#
if [[ -z "${*:-}" ]] || grep -Fq -- ' --base ' <<<" ${*} "; then
	images="$(
		$docker image ls --noheading \
			"${init_name}" 2>/dev/null
	)"
	if ! grep -Eq -- "^(localhost/)?${init_name#*/}" <<<"${images}"; then
		die "Initial stage not found - please execute '$(
			basename "${0}"
		) --init'"
	fi

	output
	output " ${blue}*${reset} Deploying container '${base_name#*/}' from image" \
		"'${init_name}:latest' ..."
	output

	checkids "${init_name}"

	# Handle leftover container from previous run ...
	trap '' INT
	if $docker container ps -a | grep -q -- "${base_name#*/}$"; then
		$docker container stop "${base_name#*/}"
		$docker container rm --volumes "${base_name#*/}"
	fi
	trap - INT

	# NAME:    base
	# LABELS:  (stage3_from) (entrypoint_sum)
	# USES:    (init)
	# USED_BY: build

	# For some reason, installing glibc to a ROOT results in valid libcrypt
	# symlinks being installed, but the actual libraries missing?!
	#
	(
		# Add '@preserved-rebuild' for potential outdated stage3 base-images...
		post='dev-util/pkgconf sys-libs/glibc @preserved-rebuild sys-apps/portage'
		post_use='multiarch native-extensions ssp'
		if command -v portageq >/dev/null 2>&1; then
			portageq get_repos / | grep -Fq -- 'srcshelton' &&
				post+=' sys-apps/gentoo-functions::srcshelton'
		else
			post+=' sys-apps/gentoo-functions::srcshelton'
		fi
		# shellcheck disable=SC2030
		export name="${base_name#*/}"
		# shellcheck disable=SC2030
		export image="${init_name}:latest"
		export DOCKER_CMD_VARS="--env ARCH=${arch:-${ARCH}}"
		docker_run \
				--post-pkgs="${post}" \
				--post-use="${post_use}" \
				--usepkg=y \
				--with-bdeps-auto=n \
				--with-bdeps=n \
			virtual/libc 2>&1 |
		tee ../log/"docker.${base_name#*/}.log"
	)
	output " -> ${?}"

	output
	output " ${blue}*${reset} Saving container '${base_name#*/}' as image" \
		"'${base_name}:latest' ..."
	output

	# shellcheck disable=SC2086
	trap '' INT
	if ! command -v buildah >/dev/null 2>&1; then
		$docker container commit "${base_name#*/}" "${base_name}:latest" 2>&1 |
			tee -a ../log/"docker.${base_name#*/}.log"
	else
		buildah commit --squash "${base_name#*/}" "${base_name}:latest" 2>&1 |
			tee -a ../log/"docker.${base_name#*/}.log"
	fi
	$docker container rm --volumes "${base_name#*/}" 2>&1 |
		tee -a ../log/"docker.${base_name#*/}.log"
	trap - INT
	output " -> ${?}"

	output
	output " ${blue}*${reset} Stage 'base' complete, next is 'build' ..."
	output
else
	checkids "${init_name}"
fi

# Ensure that @system is correctly installed to ROOT=/ and snapshot result as
# build image.
if [[ -z "${*:-}" ]] || grep -Fq -- ' --build ' <<<" ${*} "; then
	images="$(
		$docker image ls --noheading \
			"${base_name}" 2>/dev/null
	)"
	if ! grep -Eq -- "^(localhost/)?${base_name}" <<<"${images}"; then
		die "Base stage not found - please execute '$(
			basename "${0}"
		) --base'"
	fi

	output
	output " ${blue}*${reset} Deploying container '${build_name#*/}' ..."
	output

	checkids "${base_name}"

	# Handle leftover container from previous run ...
	trap '' INT
	# shellcheck disable=SC2015
	if $docker container ps -a | grep -q -- "${build_name#*/}$"; then
		$docker container stop "${build_name#*/}"
		$docker container rm --volumes "${build_name#*/}"
	fi
	# shellcheck disable=SC2015
	$docker image ls --noheading \
		"${build_name}-root:latest" 2>/dev/null |
	grep -Eq -- "^(localhost/)?${build_name}-root\s+latest\s" && {
		# shellcheck disable=SC2140
		$docker \
				${IMAGE_ROOT:+--storage-opt="overlay.imagestore=${GRAPH_ROOT}" --root "${IMAGE_ROOT}"} \
			image rm "${build_name}-root:latest"
	} || :
	trap - INT

	# NAME:    build
	# LABELS:  envrionment_from
	# USES:    base env
	# USED_BY: service

	if command -v portageq >/dev/null 2>&1; then
		python_target="${python_target_override:-$( portageq envvar 'PYTHON_SINGLE_TARGET' )}"
	fi
	if [[ -z "${python_target:-}" ]]; then
		python_target="${python_default_target:-}"
	fi

	# With the addition of the '--squash-all' parameter, we should end up
	# with chained 'env', 'stage3', 'init', and 'base' images; a unified
	# 'build' pre-image with one layer on top for the post-'container
	# build' changes which are committed below (as 'build') - and then
	# services are re-squashed when 'gentoo-build'-svc.docker invokes
	# 'Dockerfile.*service' to produce the service-container image.
	#
	# shellcheck disable=SC2086,SC2140
	$docker ${IMAGE_ROOT:+--storage-opt="overlay.imagestore=${GRAPH_ROOT}" --root "${IMAGE_ROOT}"} \
			image build \
					--build-arg env_id="${env_id}" \
					--build-arg environment_filter="${environment_filter}" \
					--compress \
					--file 'Dockerfile.build' \
					${debug:+--loglevel 3 ${DEBUG_EXTRA_ARGS:-}} \
					--network none \
					--no-cache \
					--platform "linux/${docker_arch}" \
					--squash-all \
					--tag "${build_name}-root:latest" \
				. 2>&1 |
		tee ../log/"docker.${build_name#*/}.log"
					#--network slirp4netns \

	(
		# dev-libs/icu is needed for circular dependencies on
		#   icu -> python -> sqlite -> icu
		#
		# sys-libs/libeudev is needed to ensure correct dependencies in the
		# build root
		# sys-apps/sed is needed due to use of 'sed -z', which busybox doesn't
		# support
		#
		# Even though we want a minimal set of flags at this point, gcc's flags
		# are significant since they'll affect the compiler facilities
		# available to all packages built later...
		# FIXME: Source these flags from package.use
		#
		# shellcheck disable=SC2031
		export name="${build_name#*/}"
		# shellcheck disable=SC2031
		export image="${build_name}-root:latest"
		# shellcheck disable=SC2030
		if [[ -n "${IMAGE_ROOT:-}" ]]; then
			export DOCKER_VARS="--storage-opt=\"overlay.imagestore=${GRAPH_ROOT}\" --root \"${IMAGE_ROOT}\""
		fi
		# shellcheck disable=SC2086
		if eval $docker ${DOCKER_VARS:-} container exists --external "${name}"; then
			warn "Container with name '${name}' already exists:"
			eval $docker ${DOCKER_VARS:-} container ps --noheading -a | grep -F "${name}"
			eval $docker ${DOCKER_VARS:-} container stop "${name}" || :
			eval $docker ${DOCKER_VARS:-} container rm -v "${name}"
		fi
		docker_run \
				  ${use_pypy_pre:+--pre-pkgs="${use_pypy_pre}"} \
				  ${use_pypy_pre_use:+--pre-use="${use_pypy_pre_use}"} \
				--post-pkgs="app-arch/tar${use_pypy_post:+ ${use_pypy_post}}" \
				--post-use="-* ${use_essential:-} xattr ${use_pypy_post_use:-}" \
				  ${use_pypy_post_remove:+--post-remove="${use_pypy_post_remove}"} \
				--update \
				--usepkg=y \
				--with-bdeps-auto=n \
				--with-bdeps=n \
				--with-use="$( echo \
					"-* -lib-only" \
					"pkg-config ${use_essential:-} curl_ssl_openssl openssl ssl " \
					"python_single_target_${python_target}" \
					"python_targets_${python_target}" \
					"${use_pypy_use:+python_targets_pypy3 ${use_pypy_use:-}}" \
					"${use_essential_gcc:-}"
				  )" \
			sys-devel/gcc sys-apps/sed dev-libs/icu dev-util/pkgconf sys-libs/libeudev \
			@system \
			${use_pypy:+sys-apps/portage ${use_pypy:-}} 2>&1 |
		tee -a ../log/"docker.${build_name#*/}.log"
	)
	output " -> ${?}"

	output
	output " ${blue}*${reset} Saving container '${build_name#*/}' as image" \
		"'${build_name}:latest' ..."
	output
	trap '' INT
	# shellcheck disable=SC2031,SC2086,SC2140
	if ! command -v buildah >/dev/null 2>&1; then
		$docker \
					${IMAGE_ROOT:+--storage-opt="overlay.imagestore=${GRAPH_ROOT}" --root "${IMAGE_ROOT}"} 2>&1 \
				container commit "${build_name#*/}" "${build_name}:latest" |
			tee -a ../log/"docker.${build_name#*/}.log"
	else
		buildah \
					${IMAGE_ROOT:+--storage-opt="overlay.imagestore=${GRAPH_ROOT}" --root "${IMAGE_ROOT}"} 2>&1 \
				commit \
						--squash \
					"${build_name#*/}" "${build_name}:latest" |
			tee -a ../log/"docker.${build_name#*/}.log"
	fi
	# shellcheck disable=SC2031,SC2086,SC2140
	$docker \
				${IMAGE_ROOT:+--storage-opt="overlay.imagestore=${GRAPH_ROOT}" --root "${IMAGE_ROOT}"} 2>&1 \
			container rm --volumes "${build_name#*/}" |
		tee -a ../log/"docker.${build_name#*/}.log"
	# shellcheck disable=SC2031,SC2086,SC2140
	$docker \
				${IMAGE_ROOT:+--storage-opt="overlay.imagestore=${GRAPH_ROOT}" --root "${IMAGE_ROOT}"} 2>&1 \
			image rm "${build_name}-root:latest" |
		tee -a ../log/"docker.${build_name#*/}.log"
	output " -> ${?}"
	trap - INT

	output
	output " ${blue}*${reset} Stage 'build' complete - all done"
	output
else
	checkids "${base_name}"
fi

if [[ -z "${*:-}" ]] || (( build_helper )) || grep -Fq -- ' --force-helper ' <<<" ${*} "; then
	if type -pf portageq >/dev/null 2>&1; then
		# Running on Gentoo...

		if (( build_helper )); then
			if (( force )) || grep -Fq -- ' --force-helper ' <<<" ${*} "; then
				warn "Forcing creation of unnecessary helper image on Gentoo platform"
			else
				die "Helper image unneeded on Gentoo platform - use '--force' to enable creation"
			fi
		else
			build_helper=0
		fi
	fi

	if (( build_helper )); then
		popd >/dev/null 2>&1 || exit 1
		if ! [[ -x gentoo-build-svc.docker ]]; then
			warn "Cannot execute 'gentoo-build-svc.docker' script (in directory '${PWD}') to build non-Gentoo helper image"
		else
			#if ! ((
			#	$docker image ls --noheading \
			#		"gentoo-helper:latest" 2>/dev/null | wc -l
			#)); then
				output " ${blue}*${reset} Building helper for non-Gentoo host systems ..."
				output

				if (( force )) || grep -Fq -- ' --force-helper ' <<<" ${*} "; then
					./gentoo-build-svc.docker eix --force
				else
					./gentoo-build-svc.docker eix
				fi
				output " -> ${?}"
			#fi
		fi
	fi
fi

[[ -n "${trace:-}" ]] && set +o xtrace

popd >/dev/null

exit 0

# vi: set foldmarker=()\ {,}\ \ #\  foldmethod=marker syntax=bash:
