#! /usr/bin/env bash

set -eu
set -o pipefail

trace="${TRACE:-}"
debug="${DEBUG:-}"
# With 'debug' enabled, set 'DEBUG_EXTRA_ARGS' to pass additional arguments
# to 'podman build'...
#DEBUG_EXTRA_ARGS=''

# If the python release(s) used in the upstream stage3 image differ from those
# we wish to build against or those specified in the host's
# /etc/portage/package.use file(s), then 'python_targets_override' must be set
# to the desired release below:
#declare -x python_targets_override='python3_12'

if [[ -n "${BASH_VERSINFO[0]:-}" ]] && (( BASH_VERSINFO[0] < 4 )); then
	echo >&2 "FATAL: bash-4.0.0 or later is required to run this script - on" \
		"macOS, try 'brew install bash'"
	exit 1
fi

if [[ "$( uname -s )" == 'Darwin' ]]; then
	readlink() {
		perl -MCwd -le 'print Cwd::abs_path shift' "${2}"
	}  # readlink
fi
cd "$( dirname "$( readlink -e "${0}" )" )" || exit 1

declare -i NOTIFY_MKDIR=0

# Set by common/vars.sh
#
#declare docker='docker'
#declare mail_from=''
#declare mail_to=''
#declare mail_mta=''
#declare env_name=''
#declare stage3_name=''
#declare init_name=''
#declare base_name=''
#declare build_name=''
#declare stage3_flags_file=''
#declare environment_file=''
#declare environment_filter=''
#declare base_dir=''
#declare use_cpu_arch=''
#declare gcc_target_opts=''
#declare use_cpu_flags=''
#declare use_cpu_flags_raw=''
#declare use_essential=''
#declare use_essential_gcc=''
#declare python_default_target=''
#declare JOBS=''
#declare MAXLOAD=''
#declare bold=''
#declare red=''
#declare blue=''
#declare purple=''
#declare reset=''

# Set by common/run.sh _docker_setup()
#
#declare docker_arch=''
#declare arch=''

# pkg_pypy, pkg_pypy_use & pkg_pypy_post_remove are defined in common/vars.sh
#declare pkg_pypy=''
#declare pkg_pypy_use=''
#declare pkg_pypy_post_remove=''

# shellcheck disable=SC1091
[[ ! -s common/vars.sh ]] || . common/vars.sh
# shellcheck disable=SC2034 # Set from common/vars.sh
[[ -n "${__COMMON_VARS_INCLUDED:-}" ]] || {
	echo >&2 "FATAL: Inclusion of common defaults from '${PWD}/common/vars.sh' failed"
	exit 1
}

if [ "${_command}" = 'podman' ]; then
	if [ "$( uname -s )" != 'Darwin' ]; then
		# Update: Support 'core' user for podman+machine Fedora default user...
		if [ $(( $( id -u ) )) -ne 0 ] && [ "$( id -un )" != 'core' ]; then
			# This could be an expensive check, so leave it until last...
			if "${_command}" info | grep -q -- 'rootless: false'
			then
				echo >&2 "FATAL: Please re-run '$( basename "${0}")' as" \
					"user 'root'"
				exit 1
			fi
		fi
	fi
fi

[[ -n "${base_dir:-}" ]]
[[ -d "${base_dir}" ]]
[[ -e "${base_dir}"/Dockerfile.env ]]
[[ -e "${base_dir}"/Dockerfile.init ]]
[[ -e "${base_dir}"/Dockerfile.build ]]

# shellcheck disable=SC2034
IMAGE="${base_name}:latest"
# shellcheck disable=SC1091
[[ -s common/run.sh ]] && . common/run.sh

# N.B. Below, 'docker' is a shell-function if no 'docker' binary exists...
#
if ! docker --version >/dev/null 2>&1; then
	# shellcheck disable=SC2154
	die "'${_command}' failed to execute: ${?}"
elif ! docker image build --help | grep -Fq -- '--platform'; then
	die "'${_command} image build' lacks '--platform' support (try" \
		"podman-3.x or later)"
fi

if
	[[ -z "${env_name:-}" ]] ||
		[[ -z "${stage3_name:-}" ]] ||
		[[ -z "${init_name:-}" ]] ||
		[[ -z "${base_name:-}" ]] ||
		[[ -z "${build_name:-}" ]]
then
	die "Image names not correctly set in '$( pwd )/common/vars.sh'"
fi

declare target_opt=''
declare -i build_helper=0
declare -i force=0

if [[ -n "${*:-}" ]]; then
	if grep -Eq -- ' -(h|-help) ' <<<" ${*} "; then
		output >&2 "Usage: $( basename "${0}" ) [--env] [--stage3] [--init]" \
			"[[--force] --base] [[--force] --build] [[--force] --helper]"
		exit 0
	elif ! grep -Eq <<<" ${*} " -- \
		'^(\s*--(env|stage3|init|base|build|helper|force|force-helper)\s*){1,7}$'
	then
		die "Unknown args '${*}'"
	fi

	if grep -Fq -- ' --force ' <<<" ${*} "; then
		if ! grep -Eq -- ' --(base|build|helper) ' <<<" ${*} "; then
			die "'--force' is only valid with '--base', '--build', or" \
				"'--helper'"
		fi
	fi
fi

declare python_single_target="${python_targets_override:+"${python_targets_override%%" "*}"}"
declare python_targets="${python_targets_override:-}"
if [[ -z "${python_targets:-}" ]] && type -pf portageq >/dev/null 2>&1; then
	python_targets="$( portageq envvar 'PYTHON_SINGLE_TARGET' )"
fi
if [[ -z "${python_targets:-}" ]]; then
	python_targets="${python_default_target:-}"
fi

declare mask_file=''
if [[ -n "${arch:-}" ]] &&
	[[ -f "${base_dir}/etc/portage/profile/use.mask.${arch}" ]]
then
	mask_file="${base_dir}/etc/portage/profile/use.mask.${arch}"
fi
[[ -z "${mask_file:-}" ]] &&
	mask_file="${base_dir}/etc/portage/profile/use.mask"
if [[ -n "${python_single_target:-}" ]]; then
	[[ "${python_single_target}" =~ ^python[[:digit:]]_[[:digit:]]+$ ]] ||
		die "python_single_target value '${python_single_target}'" \
			"doesn't appear to be a valid python version" \
			"(matching 'pythonX_Y', e.g. 'python3_12')"
	if [[ -f "${mask_file}" ]]; then
		if sed 's/#.*$//' "${mask_file}" |
			grep -Fw -- "^python_single_target_${python_single_target}"
		then
			die "python_single_target value" \
				"'python_single_target_${python_single_target}'" \
				"is masked by '${mask_file}'"
		fi
	fi
fi
if [[ -n "${python_targets:-}" ]]; then
	for python_target in ${python_targets}; do
		[[ "${python_target}" =~ ^python[[:digit:]]_[[:digit:]]+$ ]] ||
			die "python_targets value '${python_target}'" \
				"doesn't appear to be a valid python version" \
				"(matching 'pythonX_Y', e.g. 'python3_12')"
		if [[ -f "${mask_file}" ]]; then
			if sed 's/#.*$//' "${mask_file}" |
				grep -Fw -- "^python_targets_${python_target}"
			then
				die "python_targets value 'python_targets_${python_target}' is" \
					"masked by '${mask_file}'"
			fi
		fi
	done
fi
unset mask_file

declare -a args=()
for arg in "${@:-}"; do
	case "${arg:-}" in
		*helper)
			build_helper=1
			;;
		--force)
			force=1
			;;
		*)
			args+=( "${arg}" )
			;;
	esac
done
set -- "${args[@]:-}"
unset args arg

_docker_setup

[[ -d log ]] || mkdir -p log
pushd "${base_dir}" >/dev/null 2>&1 ||
	die "chdir() to '${base_dir}' failed; ${?}"

checkids() {
	local name="${1:-}"
	local tag="${2:-"latest"}"

	#inherit docker stage3_name env_id env_name gentoo_stage3_id bold reset red
	local repo='' images='' stage3_env_id='' stage3_src_id=''

	if [[ -z "${name:-}" ]]; then
		error "Image name not set"
		return 1
	fi
	if [[
		-z "${_command:-}" ||
		-z "${stage3_name:-}" ||
		-z "${env_name:-}" ||
		-z "${env_id:-}"
	]]; then
		error "Required global variable not set"
		return 1
	fi

	local relation="inherited by"
	if [[ "${name#*"/"}" == "${stage3_name#*"/"}" ]]; then
		relation="about to be linked to"
	fi

	if ! [[ "${name}" =~ / ]]; then
		repo='localhost/'
	fi
	images="$( docker image ls --noheading \
		"${repo}${name}:${tag}" 2>/dev/null
	)"
	# Older releases of 'podman' exclude the repo when it is 'localhost/'...
	# FIXME: Can't we just check whether 'images' is set?
	if grep -Eq -- "^(${repo:-"${name%"/"*}"})?${name#*"/"}" <<<"${images}"
	then
		if stage3_env_id="$( # <- Syntax
				stage3_repo=''
				if ! [[ "${stage3_name}" =~ / ]]; then
					stage3_repo='localhost/'
				fi
				docker image inspect \
						--format='{{index .Config.Labels "environment-from"}}' \
					"${stage3_repo:-}${stage3_name}:${tag}" 2>/dev/null
			)" && [[ -n "${stage3_env_id:-}" ]]
		then
			stage3_env_id="$( echo "${stage3_env_id:-}" | cut -d':' -f 2- )"

			# Does our current 'gentoo-env' image match the ID encoded in our
			# local stage3?
			# N.B.: 'env_id' inherited from global scope
			if [[ "${env_id}" != "${stage3_env_id:-}" ]]; then
				output >&2 "${bold:-}WARN${reset:-}:  ${red:-}" \
					"The current '${env_name#*"/"}' image (${env_id})" \
					"differs from that used to build the" \
					"'${stage3_name#*"/"}' image (${stage3_env_id:-})" \
					"${relation} this stage${reset:-}"
			fi
		fi

		if [[ -n "${gentoo_stage3_id:-}" ]]; then
			# N.B.: Only valid for our 'init' and (local) 'stage3' images
			if stage3_src_id="$( # <- Syntax
					docker image inspect \
							--format='{{index .Config.Labels "stage3-from"}}' \
						"${repo}${name}:${tag}" 2>/dev/null
				)" && [[ -n "${stage3_src_id:-}" ]]
			then
				stage3_src_id="$( # <- Syntax
					echo "${stage3_src_id:-}" |
					awk -F':' '{ print $NF }'
				)"

				# Does our upstream stage3 match the ID encoded in our current
				# image?
				if [[ "${gentoo_stage3_id}" != "${stage3_src_id:-}" ]]; then
					output >&2 "${bold:-}WARN${reset:-}:  ${red:-}" \
						"The upstream 'stage3' image (${gentoo_stage3_id})" \
						"differs from that used to build the '${name#*"/"}'" \
						"image (${stage3_src_id:-}) ${relation} this" \
						"stage${reset}"
				fi
			fi
		fi
	fi

	# The above is a warning rather than an error, so...
	return 0
}  # checkids

makedir() {
	local dir="${1:-}"

	[[ -n "${dir}" ]] || return 1

	if ! (( NOTIFY_MKDIR )) && (( EUID )); then
		NOTIFY_MKDIR=1

		info "In order to run on a non-gentoo system, we need to create" \
			"several system"
		info "directories."
		info "You may be now prompted to enter your password in order to" \
			"authenticate"
		info "with superuser credentials and allow for this to proceed:"
	fi

	if [[ "$( uname -s )" == 'Darwin' ]] || (( EUID )); then
		sudo mkdir -pm 0755 "${dir}" || die "mkdir() on '${dir}' failed: ${?}"
		sudo chown ${EUID} "${dir}" || die "chown() on '${dir}' failed: ${?}"
	else
		mkdir -p "${dir}" || die "mkdir() on '${dir}' failed: ${?}"
	fi

	info " * ${dir}"
}  # makedir

declare repo_path_srcshelton=''

# Check for environment sanity...
if ! type -pf portageq >/dev/null 2>&1; then
	warn "Not running on Gentoo host system, not checking eclass overrides"

	# shellcheck disable=SC2043
	for dir in 'repos.conf' 'package.mask' 'savedconfig'; do
		[[ -d "/etc/portage/${dir}" ]] || makedir "/etc/portage/${dir}"
	done
	unset dir
	for cfg in DEFAULT.conf gentoo.conf srcshelton.conf; do
		[[ -s /etc/portage/repos.conf/${cfg} ]] ||
			cp -v etc/portage/repos.conf/${cfg} /etc/portage/repos.conf/
	done
	unset cfg

	declare -i private_gentoo_clone=0
	declare repo_path_gentoo='/var/db/repo/gentoo'
	repo_path_srcshelton='/var/db/repo/srcshelton'

	# FIXME: Hardcoded paths, use repos.conf
	if
		[[ ! -d "${repo_path_gentoo}" ]] &&
			[[ ! -d /var/db/repos/gentoo ]]
	then
		# macOS 'df' lacks the below options
		if [[ "$( uname -s )" != 'Darwin' ]]; then
			for dir in /var/db/repo{,s} /var/db; do
				if [[ -d "${dir}" ]]; then
					# FIXME: Figure out best macOS implementation
					if (( $( # <- Syntax
						df --block-size=1G --output=avail "${dir}" |
						tail -n 1
					) < 2 )); then
						die "Insufficient filesystem space to download" \
							"Gentoo Portage repo: 2GB required"
					fi
					break
				fi
			done
			unset dir
		fi

		type -pf git >/dev/null 2>&1 || die "required binary 'git' missing"

		note "Creating local Gentoo Portage repo mirror at" \
			"'${repo_path_gentoo}' ..."

		# shellcheck disable=SC2043,SC2066
		for dir in "$( dirname "${repo_path_gentoo}" )"; do
			[[ -d "${dir}" ]] || makedir "${dir}"
		done
		unset dir

		git clone https://github.com/gentoo/gentoo.git "${repo_path_gentoo}" ||
			die "git 'clone' operation failed: ${?}"
		if ! git config --global --get-all safe.directory |
			grep -q "${repo_path_gentoo%"/"}"
		then
			git config --global --add safe.directory "${repo_path_gentoo}" ||
				die "git safe directory addition of '${repo_path_gentoo}'" \
					"failed: ${?}"
		fi

		private_gentoo_clone=1

	elif [[ -d /var/db/repos/gentoo ]]; then
		repo_path_gentoo='/var/db/repos/gentoo'
	fi

	if
		[[ ! -d "${repo_path_srcshelton}" ]] &&
			[[ ! -d /var/db/repos/srcshelton ]]
	then
		type -pf git >/dev/null 2>&1 || die "required binary 'git' missing"

		note "Creating custom packages repo mirror at" \
			"'${repo_path_srcshelton}' ..."

		# shellcheck disable=SC2043,SC2066
		for dir in "$( dirname "${repo_path_srcshelton}" )"; do
			[[ -d "${dir}" ]] || makedir "${dir}"
		done
		unset dir

		git clone \
				https://github.com/srcshelton/gentoo-ebuilds.git \
				"${repo_path_srcshelton}" ||
			die "git 'clone' operation failed: ${?}"
		if ! git config --global --get-all safe.directory |
			grep -q "${repo_path_srcshelton%"/"}"
		then
			git config --global --add safe.directory \
					"${repo_path_srcshelton}" ||
				die "git safe directory addition of" \
					"'${repo_path_srcshelton}' failed: ${?}"
		fi

	elif [[ -d /var/db/repos/srcshelton ]]; then
		repo_path_srcshelton='/var/db/repos/srcshelton'
	fi

	declare ref=''
	if
		[[ -s "${repo_path_srcshelton}/.portage_commit" ]] &&
			ref="$( # <- Syntax
				grep -Fv '#' "${repo_path_srcshelton}/.portage_commit"
			)" &&
				[[ -n "${ref:-}" ]]
	then
		if ! git config --global --get-all safe.directory |
			grep -q "${repo_path_gentoo%"/"}"
		then
			git config --global --add safe.directory "${repo_path_gentoo}" ||
				die "git safe directory addition of '${repo_path_gentoo}'" \
					"failed: ${?}"
		fi
		pushd "${repo_path_gentoo}" >/dev/null 2>&1
		declare head=''
		head="$( git rev-parse HEAD )"
		if [[ "${ref}" == "${head:-}" ]]; then
			note "Local Gentoo Portage repo mirror is in sync with custom" \
				"packages repo at commit '${ref:0:7}'"
		elif git rev-parse -q --verify "${ref}^{commit}" >/dev/null 2>&1; then
			info "Local Gentoo Portage repo mirror is currently at commit" \
				"'${head:0:7}' but can be reverted to custom packages repo" \
				"target commit '${ref:0:7}'"
			if (( private_gentoo_clone )); then
				if git reset --hard "${ref}"; then
					info "Local Gentoo Portage repo mirror is now in sync" \
						"with custom packages repo at commit '${ref:0:7}'"
				else
					error "Unable to reset local Gentoo Portage repo mirror" \
						"to commit '${ref:0:7}': ${?}"
				fi
			else
				warn "Not changing local Gentoo Portage repo mirror contents" \
					"for potentailly shared clone"
			fi
		else
			error "Custom packages target commit '${ref:0:7}' does not exist" \
				"in local Gentoo Portage repo mirror - mirror out of date?"
		fi
		unset head
		popd >/dev/null 2>&1
	fi
	unset ref

	for dir in /var/cache/portage/dist /var/log/portage /var/cache/portage/pkg
	do
		[[ -d "${dir}" ]] || makedir "${dir}"
	done
	unset dir

	unset private_gentoo_clone repo_path_gentoo

	popd >/dev/null 2>&1

	# Flags may have changed...
	unset __COMMON_VARS_INCLUDED

	# shellcheck disable=SC1091
	[[ ! -s common/vars.sh ]] || . common/vars.sh
	# shellcheck disable=SC2034 # Set from common/vars.sh
	[[ -n "${__COMMON_VARS_INCLUDED:-}" ]] || {
		echo >&2 "FATAL: Inclusion of common defaults from" \
			"'${PWD}/common/vars.sh' failed"
		exit 1
	}

	pushd "${base_dir}" >/dev/null 2>&1 ||
		die "chdir() to '${base_dir}' failed; ${?}"

else # type -pf portageq >/dev/null 2>&1; then

	declare -i rc=0

	while read -r repo; do
		# FIXME: Discover default rather than assuming 'gentoo'?
		[[ "${repo}" == 'gentoo' ]] && continue

		while read -r dir; do
			if [[ -d "${dir}"/eclass ]]; then
				grep -hR eclass /etc/portage/repos.conf |
						sed 's/#.*//' |
						grep '^eclass-overrides' |
						cut -d '=' -f 2- |
						grep -Fqw -- "${repo}" &&
					continue
				warn "ebuild repo '${repo}' contains class overrides, but" \
					"portage isn't configured to allow their use"
				warn "Add/update 'eclass-overrides = ${repo}' in" \
					"/etc/portage/repos.conf"
				rc=1
			fi
		done < <( portageq get_repo_path "${EROOT:-"/"}" "${repo}" )
		unset dir

	done < <( portageq get_repos "${EROOT:-"/"}" | xargs -n 1 )
	unset repo

	(( rc )) && sleep 5
	unset rc

	# FIXME: Discover default rather than assuming 'gentoo'?
	declare repo_path_gentoo=''
	declare ref=''
	repo_path_gentoo="$( # <- Syntax
		portageq get_repo_path "${EROOT:-"/"}" 'gentoo' 2>/dev/null
	)"
	repo_path_srcshelton="$( # <- Syntax
		portageq get_repo_path "${EROOT:-"/"}" 'srcshelton' 2>/dev/null
	)"
	if
		[[ -n "${repo_path_gentoo:-}" && -d "${repo_path_gentoo}" ]] &&
			[[ -n "${repo_path_srcshelton:-}" && -d "${repo_path_srcshelton}" ]]
	then
		if
			[[ -s "${repo_path_srcshelton}/.portage_commit" ]] &&
				ref="$( # <- Syntax
					grep -Fv '#' "${repo_path_srcshelton}/.portage_commit"
				)" &&
					[[ -n "${ref:-}" ]]
		then
			if ! git config --global --get-all safe.directory |
				grep -q "${repo_path_gentoo%"/"}"
			then
				git config --global --add safe.directory "${repo_path_gentoo}" ||
					die "git safe directory addition of '${repo_path_gentoo}'" \
						"failed: ${?}"
			fi
			pushd "${repo_path_gentoo}" >/dev/null 2>&1
			declare head=''
			head="$( git rev-parse HEAD )"
			if [[ "${ref}" == "${head:-}" ]]; then
				note "Local Gentoo Portage repo mirror is in sync with" \
					"custom packages repo at commit '${ref:0:7}'"
			elif
				git rev-parse -q --verify "${ref}^{commit}" >/dev/null 2>&1
			then
				warn "Local Gentoo Portage repo mirror is currently at" \
					"commit '${head:0:7}' but can be reverted to custom" \
					"packages repo target commit '${ref:0:7}'"
			else
				error "Custom packages target commit '${ref:0:7}' does not" \
					"exist in local Gentoo Portage repo mirror - mirror out" \
					"of date?"
			fi
			unset head
			popd >/dev/null 2>&1
		else
			warn "No upstream commit marker found in" \
				"'${repo_path_srcshelton}/.portage_commit'"
		fi
	else
		die "Could not determine essential repo paths for 'gentoo'" \
			"(${repo_path_gentoo:-}) or 'srcshelton'" \
			"(${repo_path_srcshelton:-})"
	fi
	unset ref repo_path_gentoo
fi

# 'cut' separately to emulate 'pipefail' when using /bin/sh
#
# (... which we aren't any longer - but pipefail does seem to cause some
# unexpected behaviour)
#
declare sum=''
sum="$( sha1sum entrypoint.sh )"
sum="$( echo "${sum}" | cut -d' ' -f 1 )"

gentoo_stage3_tag='latest'
# https://hub.docker.com/r/gentoo/stage3 tag-naming is a mess - not only does
# it keep changing, but there's now an inconsistency as to whether the init
# system is tagged onto the image or not (for example, the amd64 image used to
# be 'amd64-nomultilib', which is now no longer being updated.  There are now
# new 'nomultilib' and 'amd64-nomultilib-openrc' images - while the 32bit image
# name has changed from 'x86' to 'i686-openrc' and the ARM image names are
# unchanged in the case of 'openrc' but now also have variants with a 'systemd'
# suffix)
# Update: As-of 18th March 2022, the 'arm64' image is no longer being updated,
# but the 'latest' image is now multi-arch, and there's an 'arm64-openrc' image
# also...
#
# shellcheck disable=SC2154
case "${docker_arch}" in
	'amd64')
		gentoo_stage3_tag="${docker_arch}-nomultilib-openrc" ;;
	'arm64')
		gentoo_stage3_tag="${docker_arch}-openrc" ;;
	'arm/v7')
		gentoo_stage3_tag='armv7a_hardfp-openrc' ;;
	'arm/v6')
		gentoo_stage3_tag='armv6j_hardfp-openrc' ;;
	'i386')
		gentoo_stage3_tag='i686-openrc' ;;
esac
target_opt="${gcc_target_opts:-}"
case "${docker_arch}" in
	'arm'*)
		# See https://community.arm.com/developer/tools-software/tools/b/tools-software-ides-blog/posts/compiler-flags-across-architectures-march-mtune-and-mcpu
		[[ -z "${gcc_target_opts:-}" ]] &&
			target_opt='-mcpu=native' ;;
esac
env_id="$( docker image ls --noheading \
		--format='{{.ID}}' \
	"${env_name}:latest"
)" || die "Could not determine environment stage image name"
local_stage3_id="$( docker image ls --noheading \
		--format='{{.ID}}' \
	"${stage3_name}:latest"
)" || die "Could not determine local stage3 image name"

[[ -z "${trace:-}" ]] || set -o xtrace

# Create empty stage with shared environment variables ...
#
if [[ -z "${*:-}" ]] || grep -Fq -- ' --env ' <<<" ${*} "; then
	output
	# shellcheck disable=SC2154
	output " ${blue}*${reset} Creating image '${env_name}:latest' ..."
	output

	# NAME:    env
	# LABELS:
	# USES:
	# USED_BY: stage3 build

	declare -a build_args=()
	build_args+=( # <- Syntax
		--platform "linux/${docker_arch}"
		--build-arg ARCH="${arch}"
		--build-arg PROFILE_PATH="${profile:-}"
		--build-arg CHOST="${chost:-}"
		--build-arg JOBS="${JOBS:-}"
		--build-arg MAXLOAD="${MAXLOAD:-}"
		--build-arg MAIL_FROM="${mail_from:-}"
		--build-arg MAIL_TO="${mail_to:-}"
		--build-arg MAIL_MTA="${mail_mta:-}"
		--build-arg SET_TERM="${TERM:-}"
		--build-arg SET_USE_ESSENTIAL="${use_essential:-}"
		--build-arg SET_USE_ESSENTIAL_GCC="${use_essential_gcc:-}"
		--compress
		--file 'Dockerfile.env'
		--network none
		--no-cache
		--tag "${env_name}:latest"
		--rm
	)
	[[ -z "${use_cpu_arch:-}" ]] || build_args+=( # <- Syntax
		--build-arg "CPU_FLAGS_${use_cpu_arch^^}=${use_cpu_flags_raw}"
	)
	[[ -z "${target_opt:-}" ]] || build_args+=( # <- Syntax
		--build-arg TARGET_OPT="${target_opt}"
	)
	# shellcheck disable=SC2206
	[[ -z "${debug:-}" ]] || build_args+=( # <- Syntax
		--loglevel 3
		${DEBUG_EXTRA_ARGS:-}
	)
	docker image build "${build_args[@]}" . 2>&1 |
		tee ../log/"docker.${env_name#*"/"}.log"
	output " -> ${?}"
	unset build_args

	[[ "${*:-}" = '--env' ]] && exit 0

	env_id="$( docker image ls --noheading \
			--format='{{.ID}}' \
		"${env_name}:latest" 2>/dev/null
	)"

	output
	output " ${blue}*${reset} Stage 'env' complete, next is 'stage3' ..."
	output
fi

gentoo_stage3_image="$( # <- Syntax highlight failure
	grep -- '^ARG gentoo_stage3_image=' Dockerfile.stage3 |
	cut -d'"' -f 2
)"

declare ref=''
declare -i rc=0 need_pull=1
trap '' INT

# We have to 'pull' manually, or else this stage fails ...
if [[ "${gentoo_stage3_tag}" = 'latest' ]]; then
	info "Using upstream '${gentoo_stage3_image}' tag" \
		"'${gentoo_stage3_tag}'"

	case "$( docker image pull --help )" in
		*'--platform'*)
			docker image pull "${gentoo_stage3_image}:latest" \
				--platform "linux/${docker_arch}" || rc=${?}
			;;
		*'--override-arch'*)
			docker image pull "${gentoo_stage3_image}:latest" \
				--override-arch "${docker_arch}" || rc=${?}
			;;
		*'--arch'*)
			docker image pull "${gentoo_stage3_image}:latest" \
				--arch "${docker_arch}" || rc=${?}
			;;
		*)
			die "Could not determine method to retrieve" \
				"non-native architecture with" \
				"'${_command} image pull'"
			;;
	esac

	need_pull=0
elif [[ -n "${repo_path_srcshelton:-}" ]] &&
		[[ -d "${repo_path_srcshelton}" ]]
then
	if [[ -s "${repo_path_srcshelton}/.image_digests" ]]; then
		ref="$( # <- Syntax
			grep -m 1 "^${docker_arch} " \
					"${repo_path_srcshelton}/.image_digests" |
				cut -d' ' -f 2-
		)"
		if ! [[ "${ref%":"*}" == 'sha256' ]]; then
			warn "Unable to retrieve SHA256 digest for image" \
				"'${gentoo_stage3_image}:${gentoo_stage3_tag}' with" \
				"with architecture '${docker_arch}' from file" \
				"'${repo_path_srcshelton}/.image_digests'"
			need_pull=1
		else
			info "Using '${gentoo_stage3_image}' pin '${ref}'"

			# podman-4.6.x has strange behaviour where untagging an image
			# also seems to lose the associated SHA256?
			#
			# See https://github.com/containers/podman/issues/19594
			#
			# We can work around this by untagging *before* pulling...
			#
			if [[ -n "$( # <- Syntax
				docker image list \
					-q \
					--filter "reference=${gentoo_stage3_image}:${gentoo_stage3_tag}"
			)" ]]
			then
				if ! docker image untag \
						"${gentoo_stage3_image}:${gentoo_stage3_tag}"
				then
					docker --debug image untag \
							"${gentoo_stage3_image}:${gentoo_stage3_tag}" ||
						die "${_command} image untag failed to remove" \
							"'${gentoo_stage3_image}:${gentoo_stage3_tag}' tag"
				fi
			fi

			info "Pulling image '${gentoo_stage3_image}@${ref}' ..."
			if ! docker image pull "${gentoo_stage3_image}@${ref}"; then
				docker --debug image pull "${gentoo_stage3_image}@${ref}" ||
					rc=${?}
			else
				info "Tagging '${ref}' as" \
					"'${gentoo_stage3_image}:${gentoo_stage3_tag}'"

				if ! docker image tag "${gentoo_stage3_image}@${ref}" \
						"${gentoo_stage3_image}:${gentoo_stage3_tag}"
				then
					docker --debug image tag \
						"${gentoo_stage3_image}@${ref}" \
						"${gentoo_stage3_image}:${gentoo_stage3_tag}" || :
					warn "Pull of pinned image failed - reverting to tag" \
						"'${gentoo_stage3_tag}'"
					need_pull=1
				else
					rc=0
					need_pull=0
				fi
			fi
		fi
	fi
fi

if (( need_pull )); then
	warn "Pulling image '${gentoo_stage3_image}:${gentoo_stage3_tag}' ..."
	if ! docker image pull "${gentoo_stage3_image}:${gentoo_stage3_tag}"; then
		rc=${?}
		docker --debug image pull "${gentoo_stage3_image}:${gentoo_stage3_tag}"
	fi
fi

unset need_pull
trap - INT

if (( rc )); then
	die "'${_command} image pull' failed to retrieve image" \
		"'${gentoo_stage3_image}:${gentoo_stage3_tag}' for architecture" \
		"'${docker_arch}'"
fi
unset rc

if [[ -n "${ref:-}" ]]; then
	# 'podman image ls' won't show images by SHA256 reference...
	#gentoo_stage3_id="$( docker image ls --noheading \
	#		--format='{{.ID}}' \
	#	"${gentoo_stage3_image}@${ref}" 2>/dev/null
	#)" || :
	gentoo_stage3_id="$( docker image ls --noheading --digests \
			--format='{{.Digest}} {{.ID}}' 2>/dev/null |
		grep -F -- "${ref}" |
		awk '{ print $2 }'
	)" || :
else
	gentoo_stage3_id="$( docker image ls --noheading \
			--format='{{.ID}}' \
		"${gentoo_stage3_image}:${gentoo_stage3_tag}" 2>/dev/null
	)" || :
fi
#unset ref

if [[ -z "${*:-}" ]] || grep -Fq -- ' --stage3 ' <<<" ${*} "; then
	if [[ -z "${env_id:-}" ]]; then
		die "Environment stage not found - please run" \
			"'$( basename "${0}" ) --env'"
	fi

	output
	output " ${blue}*${reset} Creating image '${stage3_name}:latest'" \
		"${debug:+"from image ID '${gentoo_stage3_id}' "}..."
	output

	# NAME:    stage3
	# LABELS:  environment-from stage3-from
	# USES:    [gentoo/stage3-amd64] env
	# USED_BY: init

	declare -a build_args=()
	if [ 'symbolic link' = "$(
			docker run --rm --network none --entrypoint /bin/sh \
				"${gentoo_stage3_image}@${ref}" -c "stat -c '%F' /lib"
		)" ]
	then
		build_args+=( --build-arg new_root_name="split-usr-root" )
	else
		build_args+=( --build-arg new_root_name="" )
	fi
	build_args+=( # <- Syntax
		--platform "linux/${docker_arch}"
		--build-arg ARCH="${arch}"
		--build-arg env_name="${env_name}"
		--build-arg env_id="${env_id}"
		--build-arg gentoo_stage3_image="${gentoo_stage3_image}"
		--build-arg gentoo_stage3_tag="${gentoo_stage3_tag}"
		--build-arg gentoo_stage3_id="${gentoo_stage3_id}"
		--build-arg gentoo_stage3_image_ref="${gentoo_stage3_image}@${ref}"
		--compress
		--file 'Dockerfile.stage3'
		--network none
		--no-cache
		--pull=false
		--tag "${stage3_name}:latest"
	)
	[[ -z "${stage3_flags_file:-}" ]] || build_args+=( # <- Syntax
		--build-arg stage3_flags_file="${stage3_flags_file}"
	)
	# shellcheck disable=SC2206
	[[ -z "${debug:-}" ]] || build_args+=( # <- Syntax
		--loglevel 3
		${DEBUG_EXTRA_ARGS:-}
	)
	docker image build "${build_args[@]}" . 2>&1 |
		tee ../log/"docker.${stage3_name#*"/"}.log"
	output " -> ${?}"
	unset build_args

	[[ "${*:-}" == '--stage3' ]] && exit 0

	local_stage3_id="$( docker image ls --noheading \
			--format='{{.ID}}' \
		"${stage3_name}:latest" 2>/dev/null
	)"

	output
	output " ${blue}*${reset} Stage 'stage3' complete, next is 'init' ..."
	output
fi
unset ref

# Create initial image from Gentoo stage3 ...
#
# N.B. The first block below is executed if we DON'T have '--init' as an
#      argument, but may clear the command-line parameters so that the 'init'
#      block below that IS executed.
#
if [[ -n "${*:-}" ]] && ! grep -Fq -- ' --init ' <<<" ${*} "; then
	# Executed individually, `docker image ls` and `grep` both succeed.
	# With 'pipefail' disabled, the following test does the right thing.
	# However, with pipefail set the statement is interpreted to have
	# failed when run in the same pipeline?!
	#
	images="$( docker image ls --noheading \
		"${init_name}" 2>/dev/null
	)"
	if grep -Eq -- "^(localhost/)?${init_name}" <<<"${images}"; then
		imagesum="$( docker image inspect \
				--format='{{index .Config.Labels "entrypoint-sum"}}' \
			"${init_name}:latest" 2>/dev/null
		)" || :
		if [[ "${imagesum:-}" != "${sum}" ]]; then
			if (( force )); then
				output >&2
				output >&2 "${bold}WARN${reset}:  ${red}'entrypoint.sh'" \
					"checksum from '${init_name}:latest' image" \
					"(${imagesum:-"<unknown>"}) does not match file on disk" \
					"(${sum}) - forcing continuation with existing embedded" \
					"script ...${reset}"
			else
				declare -i add_init=0
				for arg in "${@:-}"; do
					case "${arg:-}" in
						--env|--stage3|--init) : ;;
						*) add_init=1 ;;
					esac
				done
				if (( add_init )); then
					output >&2
					output >&2 "${bold}WARN${reset}:  ${red}'entrypoint.sh'" \
						"checksum from '${init_name}:latest' image" \
						"(${imagesum:-"<unknown>"}) does not match file on" \
						"disk (${sum}) - rebuilding initial image ...${reset}"
					set -- "${@:-}" --init
				fi
				unset add_init
			fi
		fi
	else
		declare -i add_init=0
		for arg in "${@:-}"; do
			case "${arg:-}" in
				--env|--stage3|--init) : ;;
				*) add_init=1 ;;
			esac
		done
		if (( add_init )); then
			output >&2 "docker image '${init_name}' not found - rebuilding" \
				"initial image ..."
			set -- "${@:-}" --init
		fi
		unset add_init
	fi
fi

if [[ -z "${*:-}" ]] || grep -Fq -- ' --init ' <<<" ${*} "; then
	if [[ -z "${local_stage3_id:-}" ]]; then
		die "Local stage 3 image '${stage3_name}:latest'" \
			"not found - please execute '$( # <- Syntax
				basename "${0}"
			) --stage3'"
	fi

	output
	output " ${blue}*${reset} Creating image '${init_name}:latest' ..."
	output

	checkids "${stage3_name}"

	# NAME:    init
	# LABELS:  stage3-from entrypoint-sum
	# USES:    stage3
	# USED_BY: base

	declare -a build_args=()
	build_args+=( # <- Syntax
		--platform "linux/${docker_arch}"
		--build-arg ARCH="${arch}"
		--build-arg gentoo_stage3_image="${gentoo_stage3_image}:${gentoo_stage3_tag}"
		--build-arg gentoo_stage3_id="${gentoo_stage3_id}"
		--build-arg stage3_name="${stage3_name}"
		--build-arg entrypoint_sum="${sum}"
		--build-arg environment_filter="${environment_filter}"
		--compress
		--file 'Dockerfile.init'
		--network none
		#--network slirp4netns
		--no-cache
		--pull=false
		--tag "${init_name}:latest"
	)
	[[ -z "${stage3_flags_file:-}" ]] || build_args+=( # <- Syntax
		--build-arg stage3_flags_file="${stage3_flags_file}"
	)
	[[ -z "${environment_file:-}" ]] || build_args+=( # <- Syntax
		--build-arg environment_file="${environment_file}"
	)
	# shellcheck disable=SC2206
	[[ -z "${debug:-}" ]] || build_args+=( # <- Syntax
		--loglevel 3
		${DEBUG_EXTRA_ARGS:-}
	)
	docker image build "${build_args[@]}" . 2>&1 |
		tee ../log/"docker.${init_name#*"/"}.log"
	output " -> ${?}"
	unset build_args

	output
	output " ${blue}*${reset} Stage 'init' complete, next is 'base' ..."
	output
else
	checkids "${stage3_name}"
fi

# Launch initial image and run entrypoint script to install root @system, then
# snapshot the result to create a base image ...
#
if [[ -z "${*:-}" ]] || grep -Fq -- ' --base ' <<<" ${*} "; then
	images="$( docker image ls --noheading "${init_name}" 2>/dev/null )"
	if ! grep -Eq -- "^(localhost/)?${init_name#*"/"}" <<<"${images}"; then
		die "Initial stage not found - please execute '$( # <- Syntax
			basename "${0}"
		) --init'"
	fi

	output
	output " ${blue}*${reset} Deploying container '${base_name#*"/"}' from image" \
		"'${init_name}:latest' ..."
	output

	checkids "${init_name}"

	# Handle leftover container from previous run ...
	trap '' INT
	if docker container ps -a | grep -q -- "${base_name#*"/"}$"; then
		docker container stop "${base_name#*"/"}"
		docker container rm --volumes "${base_name#*"/"}"
	fi
	trap - INT

	# NAME:    base
	# LABELS:  (stage3-from) (entrypoint-sum)
	# USES:    (init)
	# USED_BY: build

	# For some reason, installing glibc to a ROOT results in valid libcrypt
	# symlinks being installed, but the actual libraries missing?!
	#
	(
		declare python_use='' python_pkgs=''

		if [[ -n "${python_single_target:-}" ]]; then
			python_use="python_single_target_${python_single_target}"
			# shellcheck disable=SC2001
			python_pkgs="=python-$( sed 's/^python//' \
				<<<"${python_single_target//_/.}" )*"
			for python_target in ${python_targets}; do
				# shellcheck disable=SC2001
				python_pkgs+=" =python-$( sed 's/^python//' \
					<<<"${python_target//_/.}" )*"
			done

			declare -a docker_run_args=()
			docker_run_args+=( # <- Syntax
				--entrypoint /bin/sh
				--name 'buildpkg.stage3_flags.read'
				--network none
				--rm
			)
			eval "$( # <- Syntax
				docker container run "${docker_run_args[@]}" \
					"${init_name}:latest" -c "cat ${stage3_flags_file}"
			)"
			unset docker_run_args

			declare mask_file=''
			if [[ -n "${arch:-}" ]] &&
				[[ -f "${base_dir}/etc/portage/profile/use.mask.${arch}" ]]
			then
				mask_file="${base_dir}/etc/portage/profile/use.mask.${arch}"
			fi
			[[ -z "${mask_file:-}" ]] &&
				mask_file="${base_dir}/etc/portage/profile/use.mask"
			if [[ -f "${mask_file}" ]]; then
				declare target=''
				if [[ -n "${STAGE3_PYTHON_SINGLE_TARGET:-}" ]]; then
					target="${STAGE3_PYTHON_SINGLE_TARGET}"
					if [[ "${target}" != "${python_single_target}" ]]; then
						if sed 's/#.*$//' "${mask_file}" |
							grep -Fw -- "^python_targets_${target}"
						then
							die "Upstream stage python target" \
								"'python_single_target_${target}'" \
								"is masked by '${mask_file}'"
						fi
						python_use="$( replace_flags \
							"python_targets_${target}" -- "${python_use}"
						)"
					fi
				fi  # [[ -n "${STAGE3_PYTHON_SINGLE_TARGET:-}" ]]

				if [[ -n "${STAGE3_PYTHON_TARGETS:-}" ]]; then
					for target in ${STAGE3_PYTHON_TARGETS}; do
						for python_target in ${python_targets}; do
							if [[ "${target}" != "${python_target}" ]]; then
								if sed 's/#.*$//' "${mask_file}" |
									grep -Fw -- "^python_targets_${target}"
								then
									die "Upstream stage python target" \
										"'python_targets_${target}'" \
										"is masked by '${mask_file}'"
								fi
								python_use="$( replace_flags \
									"python_targets_${target}" -- "${python_use}"
								)"
								# shellcheck disable=SC2001
								python_pkgs+=" =python-$( sed 's/^python//' \
									<<<"${python_target//_/.}" )*"
							fi
						done
					done
				fi
				unset target
			fi  # [[ -f "${mask_file}" ]]
			unset mask_file
		fi  # [[ -n "${python_target:-}" ]]

		# Add '@preserved-rebuild' for potential outdated stage3 base-images...
		post_pkgs='dev-util/pkgconf sys-libs/glibc @preserved-rebuild sys-apps/portage net-misc/curl dev-libs/nettle'
		post_use='curl_ssl_openssl -gmp multiarch native-extensions openssl ssl -ssp'
		if [[ -n "${python_use:-}" ]]; then
			# FIXME: libbsd is having a weird problem, during image-build only?
			post_pkgs+=' app-crypt/libmd dev-libs/libbsd'

			post_pkgs+=' dev-python/setuptools'
			post_use="$( replace_flags "${python_use}" -- "${post_use}" )"
		fi
		if type -pf portageq >/dev/null 2>&1; then
			portageq get_repos / | grep -Fq -- 'srcshelton' &&
				post_pkgs+=' sys-apps/gentoo-functions::srcshelton'
		else
			post_pkgs+=' sys-apps/gentoo-functions::srcshelton'
		fi
		# shellcheck disable=SC2030
		export name="${base_name#*"/"}"
		# shellcheck disable=SC2030
		export image="${init_name}:latest"
		export DOCKER_CMD_VARS="--env ARCH=${arch:-"${ARCH}"}"
		declare -a docker_run_args=()
		docker_run_args+=( # <- Syntax
			--post-pkgs="${post_pkgs}"
			--post-use="${post_use}"
			--python-targets="${python_targets}"
			--usepkg=y
			--with-bdeps-auto=n
			--with-bdeps=n
		)
		# shellcheck disable=SC2086
		_docker_run "${docker_run_args[@]}" virtual/libc ${python_pkgs:-} 2>&1 |
			tee ../log/"docker.${base_name#*"/"}.log"
	)
	output " -> ${?}"

	output
	output " ${blue}*${reset} Saving container '${base_name#*"/"}' as image" \
		"'${base_name}:latest' ..."
	output

	# shellcheck disable=SC2086
	trap '' INT
	#if ! type -pf buildah >/dev/null 2>&1; then
		docker container commit \
					--squash \
				"${base_name#*"/"}" "${base_name}:latest" 2>&1 |
			tee -a ../log/"docker.${base_name#*"/"}.log"
	#else
	#	buildah commit \
	#				--squash \
	#			"${base_name#*"/"}" "${base_name}:latest" 2>&1 |
	#		tee -a ../log/"docker.${base_name#*"/"}.log"
	#fi
	docker container rm --volumes "${base_name#*"/"}" 2>&1 |
		tee -a ../log/"docker.${base_name#*"/"}.log"
	trap - INT
	output " -> ${?}"

	output
	output " ${blue}*${reset} Stage 'base' complete, next is 'build' ..."
	output
else
	checkids "${init_name}"
fi

# Ensure that @system is correctly installed to ROOT=/ and snapshot result as
# build image.
if [[ -z "${*:-}" ]] || grep -Fq -- ' --build ' <<<" ${*} "; then
	declare -a container_args=()
	[[ -z "${IMAGE_ROOT:-}" ]] || container_args+=( # <- Syntax
		--storage-opt="overlay.imagestore=${GRAPH_ROOT}"
		--root "${IMAGE_ROOT}"
	)

	images="$( docker image ls --noheading \
		"${base_name}" 2>/dev/null
	)"
	if ! grep -Eq -- "^(localhost/)?${base_name}" <<<"${images}"; then
		die "Base stage not found - please execute '$( # <- Syntax
			basename "${0}"
		) --base'"
	fi

	output
	output " ${blue}*${reset} Deploying container '${build_name#*"/"}' ..."
	output

	checkids "${base_name}"

	# Handle leftover container from previous run ...
	trap '' INT
	# shellcheck disable=SC2015
	if docker container ps -a | grep -q -- "${build_name#*"/"}$"; then
		docker container stop "${build_name#*"/"}"
		docker container rm --volumes "${build_name#*"/"}"
	fi
	# shellcheck disable=SC2015
	if docker image ls --noheading \
			"${build_name}-root:latest" 2>/dev/null |
		grep -Eq -- "^(localhost/)?${build_name}-root\s+latest\s"
	then
		docker "${container_args[@]}" image rm "${build_name}-root:latest"
	fi
	trap - INT

	# NAME:    build
	# LABELS:  environment-from
	# USES:    base env
	# USED_BY: service

	# With the addition of the '--squash-all' parameter, we should end up
	# with chained 'env', 'stage3', 'init', and 'base' images; a unified
	# 'build' pre-image with one layer on top for the post-'container
	# build' changes which are committed below (as 'build') - and then
	# services are re-squashed when 'gentoo-build'-svc.docker invokes
	# 'Dockerfile.*service' to produce the service-container image.
	#
	declare -a build_args=()
	build_args+=( # <- Syntax
		--build-arg env_id="${env_id}"
		--build-arg environment_filter="${environment_filter}"
		--compress
		--file 'Dockerfile.build'
		--network none
		#--network slirp4netns
		--no-cache
		--platform "linux/${docker_arch}"
		--squash-all
		--tag "${build_name}-root:latest"
	)
	[[ -z "${environment_file:-}" ]] || build_args+=( # <- Syntax
		--build-arg environment_file="${environment_file}"
	)
	# shellcheck disable=SC2206
	[[ -z "${debug:-}" ]] || build_args+=( # <- Syntax
		--loglevel 3
		${DEBUG_EXTRA_ARGS:-}
	)
	docker "${container_args[@]}" image build "${build_args[@]}" . 2>&1 |
		tee ../log/"docker.${build_name#*"/"}.log"
	unset build_args

	(
		# dev-libs/icu is needed for circular dependencies on
		#   icu -> python -> sqlite -> icu
		#
		# sys-libs/libeudev is needed to ensure correct dependencies in the
		# build root
		# FIXME: Which?
		#
		# sys-apps/sed is needed due to use of 'sed -z', which busybox doesn't
		# support
		#
		# Even though we want a minimal set of flags at this point, gcc's flags
		# are significant since they'll affect the compiler facilities
		# available to all packages built later...
		# FIXME: Source these flags from package.use
		#

		# FIXME: Expose this somewhere?
		features_libeudev=0
		features_eudev=0
		if (( features_eudev )); then
			eudev='sys-fs/eudev'
		elif (( features_libeudev )); then
			eudev='sys-libs/libeudev'
		else
			eudev='virtual/libudev'
		fi
		unset features_eudev features_libeudev

		# shellcheck disable=SC2031
		export name="${build_name#*"/"}"
		# shellcheck disable=SC2031
		export image="${build_name}-root:latest"
		# shellcheck disable=SC2030
		if [[ -n "${IMAGE_ROOT:-}" ]]; then
			export DOCKER_VARS="${container_args[*]}"
		fi
		# shellcheck disable=SC2086
		if docker ${DOCKER_VARS:-} container exists --external "${name}"; then
			warn "Container with name '${name}' already exists:"
			docker ${DOCKER_VARS:-} container ps --noheading -a |
				grep -F "${name}"
			docker ${DOCKER_VARS:-} container stop "${name}" || :
			docker ${DOCKER_VARS:-} container rm -v "${name}"
		fi
		declare -a build_args=()
		# shellcheck disable=SC2046
		build_args+=( # <- Syntax
			--post-use="-* $( replace_flags 'xattr' -- "${use_essential:-}" )"
			--update
			--usepkg=y
			--with-bdeps-auto=n
			--with-bdeps=n
			--with-use="-* $( replace_flags \
					'-lib-only' 'openmp' \
					'pkg-config' \
					'curl_ssl_openssl' 'openssl' 'ssl' \
					"python_single_target_${python_single_target}" \
					$( # <- Syntax
						for python_target in ${python_targets}; do
							echo "python_targets_${python_target}"
						done
					) \
					"${pkg_pypy_use:+"python_targets_pypy3"}" \
					"${pkg_pypy_use:-}" \
				-- \
					"${use_essential:-} ${use_essential_gcc:-}"
			  )"
		)
		[[ -z "${pkg_pypy_post_remove:-}" ]] || build_args+=( # <- Syntax
			--post-remove="${pkg_pypy_post_remove}"
		)
		# @system includes virtual/ssh, which sometimes tries to pull-in
		# net-misc/dropbear rather than net-misc/openssh, so include the latter
		# to try to avoid this...
		#
		# shellcheck disable=SC2086
		_docker_run "${build_args[@]}" --exclude='net-misc/dropbear' \
				dev-libs/icu dev-util/pkgconf net-misc/openssh \
				sys-apps/locale-gen sys-apps/sed sys-apps/util-linux \
				sys-devel/gcc ${eudev} @system \
				${pkg_pypy:+"sys-apps/portage"} ${pkg_pypy:-} 2>&1 |
			tee -a ../log/"docker.${build_name#*"/"}.log"
		unset build_args
	)
	output " -> ${?}"

	output
	output " ${blue}*${reset} Saving container '${build_name#*"/"}' as image" \
		"'${build_name}-finalise:latest' ..."
	output
	trap '' INT
	# shellcheck disable=SC2031,SC2086,SC2140
	#if ! type -pf buildah >/dev/null 2>&1; then
		docker "${container_args[@]}" container commit \
					--squash \
				"${build_name#*"/"}" "${build_name}-finalise:latest" |
			tee -a ../log/"docker.${build_name#*"/"}.log"
	#else
	#	buildah "${container_args[@]}" commit \
	#				--squash \
	#			"${build_name#*"/"}" "${build_name}:latest" |
	#		tee -a ../log/"docker.${build_name#*"/"}.log"
	#fi
	# shellcheck disable=SC2031,SC2086,SC2140
	docker "${container_args[@]}" container rm --volumes "${build_name#*"/"}" |
		tee -a ../log/"docker.${build_name#*"/"}.log"
	# shellcheck disable=SC2031,SC2086,SC2140
	docker "${container_args[@]}" image rm "${build_name}-root:latest" |
		tee -a ../log/"docker.${build_name#*"/"}.log"
	output " -> ${?}"
	trap - INT

	# This is a potentially expensive additional step, but it ensures that
	# portage doesn't complain noisily if the repos which exist on-disk when
	# a build-container is run are fewer or different than those which existed
	# when the build-image was assembled...
	#
	output
	output " ${blue}*${reset} Finalising image " \
		"'${build_name#*"/"}-finalise:latest' ..."
	output
	trap '' INT
	docker "${container_args[@]}" container run \
				--name "${build_name#*"/"}-finalise" \
				--net none \
			"${build_name}-finalise:latest" --finalise-container |
		tee -a ../log/"docker.${build_name#*"/"}.log"
	output " -> ${?}"
	trap - INT

	output
	output " ${blue}*${reset} Saving container '${build_name#*"/"}-finalise'" \
		"as image '${build_name}:latest' ..."
	output
	trap '' INT
	# shellcheck disable=SC2031,SC2086,SC2140
	#if ! type -pf buildah >/dev/null 2>&1; then
		docker "${container_args[@]}" container commit \
					--squash \
				"${build_name#*"/"}-finalise" "${build_name}:latest" |
			tee -a ../log/"docker.${build_name#*"/"}.log"
	#else
	#	buildah "${container_args[@]}" commit \
	#				--squash \
	#			"${build_name#*"/"}" "${build_name}:latest" |
	#		tee -a ../log/"docker.${build_name#*"/"}.log"
	#fi
	# shellcheck disable=SC2031,SC2086,SC2140
	docker "${container_args[@]}" container rm --volumes \
			"${build_name#*"/"}-finalise" |
		tee -a ../log/"docker.${build_name#*"/"}.log"
	# shellcheck disable=SC2031,SC2086,SC2140
	docker "${container_args[@]}" image rm "${build_name}-finalise:latest" |
		tee -a ../log/"docker.${build_name#*"/"}.log"
	output " -> ${?}"
	trap - INT

	unset container_args

	output
	output " ${blue}*${reset} Stage 'build' complete - all done"
	output
else
	checkids "${base_name}"
fi

if
	[[ -z "${*:-}" ]] ||
		(( build_helper )) ||
		grep -Fq -- ' --force-helper ' <<<" ${*} "
then
	if type -pf portageq >/dev/null 2>&1; then
		# Running on Gentoo...

		if (( build_helper )); then
			if (( force )) || grep -Fq -- ' --force-helper ' <<<" ${*} "; then
				warn "Forcing creation of unnecessary helper image on Gentoo" \
					"platform"
			else
				die "Helper image unneeded on Gentoo platform - use" \
					"'--force' to enable creation"
			fi
		else
			build_helper=0
		fi
	fi

	if (( build_helper )); then
		popd >/dev/null 2>&1 || exit 1
		if ! [[ -x gentoo-build-svc.docker ]]; then
			warn "Cannot execute 'gentoo-build-svc.docker' script (in" \
				"directory '${PWD}') to build non-Gentoo helper image"
		else
			#if ! ((
			#	docker image ls --noheading \
			#		"gentoo-helper:latest" 2>/dev/null | wc -l
			#)); then
				output " ${blue}*${reset} Building helper for non-Gentoo" \
					"host systems ..."
				output

				if
					(( force )) ||
						grep -Fq -- ' --force-helper ' <<<" ${*} "
				then
					./gentoo-build-svc.docker eix --force
				else
					./gentoo-build-svc.docker eix
				fi
				output " -> ${?}"
			#fi
		fi
	fi
fi

[[ -z "${trace:-}" ]] || set +o xtrace

popd >/dev/null

exit 0

# vi: set colorcolumn=80 foldmarker=()\ {,}\ \ #\  foldmethod=marker syntax=bash sw=4 ts=4:
