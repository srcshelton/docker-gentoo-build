#! /usr/bin/env bash

if [[ -z "${NO_MEMORY_LIMITS:-}" ]]; then
	# Tiny
	#: "${PODMAN_MEMORY_RESERVATION:=256m}"
	#: "${PODMAN_MEMORY_LIMIT:=512m}"
	#: "${PODMAN_SWAP_LIMIT:=1g}"
	# Small
	#: "${PODMAN_MEMORY_RESERVATION:=512m}"
	#: "${PODMAN_MEMORY_LIMIT:=1g}"
	#: "${PODMAN_SWAP_LIMIT:=2g}"
	# Medium
	#: "${PODMAN_MEMORY_RESERVATION:=1g}"
	#: "${PODMAN_MEMORY_LIMIT:=2g}"
	#: "${PODMAN_SWAP_LIMIT:=4g}"
	# Large
	: "${PODMAN_MEMORY_RESERVATION:=2g}"
	: "${PODMAN_MEMORY_LIMIT:=4g}"
	: "${PODMAN_SWAP_LIMIT:=8g}"
	# Extra-Large
	#: "${PODMAN_MEMORY_RESERVATION:=4g}"
	#: "${PODMAN_MEMORY_LIMIT:=8g}"
	#: "${PODMAN_SWAP_LIMIT:=16g}"

	declare -i swp=$(( ( $( grep -m 1 'SwapTotal:' /proc/meminfo | awk '{ print $2 }' ) + 16 ) / 1024 / 1024 ))
	declare -i ram=$(( $( grep -m 1 'MemTotal:' /proc/meminfo | awk '{ print $2 }' ) / 1024 / 1024 ))
	declare -i changed=0
	if (( ram < ${PODMAN_MEMORY_LIMIT%g} )) || (( ( ram + swp ) < ${PODMAN_SWAP_LIMIT%g} )); then
		echo >&2 "INFO:  Host resources (rounded down to nearest 1GiB):"
		echo >&2 "         RAM:        ${ram}G"
		echo >&2 "         Swap:       ${swp}G"
		echo >&2 "INFO:  Original memory limits:"
		echo >&2 "         Soft limit: ${PODMAN_MEMORY_RESERVATION%g}G"
		echo >&2 "         Hard limit: ${PODMAN_MEMORY_LIMIT%g}G"
		echo >&2 "         RAM + Swap: ${PODMAN_SWAP_LIMIT%g}G"
	fi
	if (( ram < ${PODMAN_MEMORY_LIMIT%g} )); then
		PODMAN_MEMORY_RESERVATION="$(( ram - 1 ))g"
		PODMAN_MEMORY_LIMIT="$(( ram ))g"
		PODMAN_SWAP_LIMIT="$(( ram + swp ))g"
		changed=1
	fi
	if (( ( ram + swp ) < ${PODMAN_SWAP_LIMIT%g} )); then
		PODMAN_SWAP_LIMIT="$(( ram + swp ))g"
		changed=1
	fi
	if (( changed )); then
		echo >&2 "NOTE:  Changed memory limits based on host configuration:"
		echo >&2 "         Soft limit: ${PODMAN_MEMORY_RESERVATION%g}G"
		echo >&2 "         Hard limit: ${PODMAN_MEMORY_LIMIT%g}G"
		echo >&2 "         RAM + Swap: ${PODMAN_SWAP_LIMIT%g}G"
		echo >&2
	fi
	unset changed ram swp
fi

#debug="${DEBUG:-}"
trace="${TRACE:-}"

set -eu

[ -n "${trace:-}" ] && set -o xtrace

cd "$( dirname "$( readlink -e "${0}" )" )" || exit 1

build_name=''

# shellcheck disable=SC1091
[ ! -s common/vars.sh ] || . common/vars.sh

IMAGE="${build_name}:latest"
# shellcheck disable=SC1091
[ -s common/run.sh ] && . common/run.sh >/dev/null

# Provide a '--name' to prevent the container being removed on exit.

# Useful use-cases:
#for s in $( podman image ls | grep '^localhost.*service' | cut -d'/' -f 2- | sed 's/\s\+/:/g' | cut -d':' -f 1-2 ); do ./inspect.docker --remove --image "${s}" 'ls -d /var/db/pkg/*/*systemd* /var/db/pkg/*/*udev*'; done

if [ -n "${*:-}" ]; then
	if echo " ${*} " | grep -Eq -- ' -(h|-help) '; then
		output >&2 "Usage: $( basename "${0}" ) --image=<image> [--name=<name>] [--remove] [commands]"
		exit 0
	fi
fi

if (( EUID )); then
	die "Please re-run '$( basename "${0}" )' as user 'root'"
fi

docker_parse() {
	local arg=''

	for arg in "${@}"; do
		if [ "${name}" = '<next>' ]; then
			export name="${arg}"

		elif [ "${image}" = '<next>' ]; then
			export image="${arg}"

		elif echo "${arg}" | grep -Eq -- '^-(n|-name)(=[a-z0-9]+([._-]{1,2}[a-z0-9]+)*)?$'; then
			if echo "${arg}" | grep -Fq -- '=' ; then
				name="$( echo "${arg}" | cut -d'=' -f 2- )"
				export name
			else
				name='<next>'
			fi

		elif echo "${arg}" | grep -Eq -- '^-(i|-image)(=[a-z0-9]+([._-]{1,2}[a-z0-9]+)*)?(:.*)?$'; then
			if echo "${arg}" | grep -Fq -- '=' ; then
				image="$( echo "${arg}" | cut -d'=' -f 2- )"
				export image
			else
				image='<next>'
			fi

		elif echo "${arg}" | grep -Eq -- '^-(r|-rm|-remove)$'; then
			rm=1

		else
			#args="${args:+${args} }${arg}"
			args+=( "${arg}" )
		fi
	done
	if [ "${name}" = '<next>' ]; then
		export name=''
	else
		:
	fi
	if [ "${image}" = '<next>' ]; then
		export image=''
	else
		:
	fi

	unset arg
} # docker_parse

docker_run() {
	local -a mirrormountpoints=()
	local -a mirrormountpointsro=()
	local -a runargs=()
	local -a files=()
	local -A mountpoints=()
	local -A mountpointsro=()
	local -i skipped=0
	local -i runrc=0
	local mp='' src=''  # cwd=''
	local default_repo_path='' default_distdir_path='' default_pkgdir_path=''

	#${arr[@]+"${arr[@]}"}
	(( 0 == ${#args[@]} )) && args=( 'sh' )

	runargs=(
		$( [[ "$( uname -s )" != 'Darwin' ]] && (( $( nproc ) > 1 )) && echo "--cpuset-cpus 1-$(( $( nproc ) - 1 ))" || : )
		--init
		--name "${name}"
		--privileged
		#--network slirp4netns
		# Some code such as podman's go code tries to fetch packages from
		# IPv6-addressable hosts...
		--network host
		--pids-limit 1024
		  ${rm:+--rm}
		--ulimit nofile=1024:1024
	)
	# shellcheck disable=SC2206
	runargs+=(
		--entrypoint '/bin/sh'
		  ${ACCEPT_KEYWORDS:+--env ACCEPT_KEYWORDS}
		  ${FEATURES:=--env FEATURES}
		  ${TERM:+--env TERM}
		  ${USE:+--env USE}
		--interactive
		--tty
	)
	if [[ -r /proc/cgroups ]] && grep -q -- '^memory.*1$' /proc/cgroups &&
		[[ -n "${PODMAN_MEMORY_RESERVATION:-}" || -n "${PODMAN_MEMORY_LIMIT}" || -n "${PODMAN_SWAP_LIMIT}" ]]
	then
		runargs+=(
			${PODMAN_MEMORY_RESERVATION:+--memory-reservation ${PODMAN_MEMORY_RESERVATION}}
			${PODMAN_MEMORY_LIMIT:+--memory ${PODMAN_MEMORY_LIMIT}}
			${PODMAN_SWAP_LIMIT:+--memory-swap ${PODMAN_SWAP_LIMIT}}
		)
	fi

	if ! type -pf portageq >/dev/null 2>&1; then
		default_repo_path='/var/db/repos/gentoo /var/db/repos/srcshelton'
		default_distdir_path='/var/cache/portage/dist'
		default_pkgdir_path='/var/cache/portage/pkg'
		if [ ! -d /var/db/repos/gentoo ] && [ -d /var/db/repo/gentoo ]; then
			default_repo_path='/var/db/repo/gentoo /var/db/repo/srcshelton'
		fi
	fi
	if [ -n "${PKGDIR_OVERRIDE:-}" ]; then
		default_pkgdir_path="${PKGDIR_OVERRIDE}"
	fi

	# shellcheck disable=SC2046,SC2207
	mirrormountpointsro=(
		# We need write access to be able to update eclasses...
		#/etc/portage/repos.conf
		${default_repo_path:-$( portageq get_repo_path "${EROOT:-/}" $( portageq get_repos "${EROOT:-/}" ) )}
		#/usr/src  # Breaks gentoo-kernel-build package
		#/var/db/repo/container
		#/var/db/repo/gentoo
		#/var/db/repo/srcshelton
		#/var/db/repo/compat
	)
	mirrormountpoints=(
		#/var/cache/portage/dist
		"${default_distdir_path:-$( portageq distdir )}"
		'/var/log/portage'
	)

	#ENV PKGDIR="${PKGCACHE:-/var/cache/portage/pkg}/${ARCH:-amd64}/${PKGHOST:-docker}"
	#local PKGCACHE="${PKGCACHE:=/var/cache/portage/pkg}"
	#local PKGHOST="${PKGHOST:=docker}"
	local PKGDIR="${PKGDIR:=${default_pkgdir_path:-$( portageq pkgdir )}}"

	# Allow use of 'ARCH' variable as an override...
	print "Using architecture '${ARCH:-${arch}}' ..."
	mountpoints["${PKGDIR}"]="/var/cache/portage/pkg/${ARCH:-${arch}}/docker"
	mountpoints['/etc/portage/repos.conf']='/etc/portage/repos.conf.host'
	[ -S /var/run/syslog-ng/log ] && mountpoints['/var/run/syslog-ng/log']='/dev/log'

	cwd="$( dirname "$( readlink -e "${BASH_SOURCE[$(( ${#BASH_SOURCE[@]} - 1 ))]}" )" )"
	print "Volume/mount base directory is '${cwd}'"
	mountpointsro["${cwd}/${base_dir:+${base_dir}/}etc/portage/package.accept_keywords"]='/etc/portage/package.accept_keywords'
	if [ -s "${cwd}/${base_dir:+${base_dir}/}etc/portage/package.accept_keywords.${ARCH:-${arch}}" ]; then
		mountpointsro["${cwd}/${base_dir:+${base_dir}/}etc/portage/package.accept_keywords.${ARCH:-${arch}}"]="/etc/portage/package.accept_keywords/${ARCH:-${arch}}"
	fi
	mountpointsro["${cwd}/${base_dir:+${base_dir}/}etc/portage/package.license"]='/etc/portage/package.license'
	mountpointsro["${cwd}/${base_dir:+${base_dir}/}etc/portage/package.use.build"]='/etc/portage/package.use'

	for mp in ${mirrormountpointsro[@]+"${mirrormountpointsro[@]}"}; do
		[ -n "${mp:-}" ] || continue
		src="$( readlink -e "${mp}" )" || die "readlink() on mirrored read-only mountpoint '${mp}' failed: ${?}"
		if [ -z "${src:-}" ]; then
			warn "Skipping mountpoint '${mp}'"
			: $(( skipped = skipped + 1 ))
			continue
		fi
		runargs+=( --mount "type=bind,source=${src},destination=${mp}${docker_readonly:+,${docker_readonly}}" )
	done
	for mp in ${mirrormountpoints[@]+"${mirrormountpoints[@]}"}; do
		[ -n "${mp:-}" ] || continue
		src="$( readlink -e "${mp}" )" || die "readlink() on mirrored mountpoint '${mp}' failed: ${?}"
		if [ -z "${src:-}" ]; then
			warn "Skipping mountpoint '${mp}'"
			: $(( skipped = skipped + 1 ))
			continue
		fi
		runargs+=( --mount "type=bind,source=${src},destination=${mp}" )
	done
	for mp in ${mountpointsro[@]+"${!mountpointsro[@]}"}; do
		[ -n "${mp:-}" ] || continue
		src="$( readlink -e "${mp}" )" || die "readlink() on read-only mountpoint '${mp}' failed: ${?}"
		if [ -z "${src:-}" ]; then
			warn "Skipping mountpoint '${mp}' -> '${mountpointsro[${mp}]}'"
			: $(( skipped = skipped + 1 ))
			continue
		fi
		runargs+=( --mount "type=bind,source=${src},destination=${mountpointsro[${mp}]}${docker_readonly:+,${docker_readonly}}" )
	done
	for mp in ${mountpoints[@]+"${!mountpoints[@]}"}; do
		[ -n "${mp:-}" ] || continue
		src="$( readlink -e "${mp}" )" || die "readlink() on mountpoint '${mp}' failed (do you need to set 'PKGDIR'?): ${?}"
		if [ -z "${src:-}" ]; then
			warn "Skipping mountpoint '${mp}' -> '${mountpoints[${mp}]}'"
			: $(( skipped = skipped + 1 ))
			continue
		fi
		runargs+=( --mount "type=bind,source=${src},destination=${mountpoints[${mp}]}" )
	done

	if [ $(( skipped )) -ge 1 ]; then
		warn "${skipped} mount-points not connected to container"
		sleep 5
	fi

	unset src mp

	if [ -n "${DOCKER_VERBOSE:-}" ]; then
		output
		[ -n "${DOCKER_VARS:-}" ] && output "VERBOSE: DOCKER_VARS is '${DOCKER_VARS}'"
		local arg='' next=''
		for arg in "${runargs[@]}"; do
			case "${next}" in
				mount)
					arg="$(
						sed -r \
								-e 's/^type=/type: /' \
								-e 's/,(src|source)=/\tsource: /' \
								-e 's/,(dst|destination)=/\tdestination: /' \
								-e 's/, ro=true$/\tRO/' \
							<<<"${arg}"
					)"
					output "VERBOSE: Mount point '${arg}'"
					;;
				volume)
					output "VERBOSE: Volume '${arg}'"
					;;
			esac
			if [[ "${arg}" =~ ^--(mount|volume)$ ]]; then
				next="${arg#--}"
			else
				next=''
			fi
		done | column -t -s $'\t'
		output
	fi

	print "Starting container with command '$docker container run ${runargs[*]} ${image} ${*}'"
	# shellcheck disable=SC2086
	$docker \
		container run \
			"${runargs[@]}" \
			${DOCKER_EXTRA_MOUNTS:-} \
			${DOCKER_VOLUMES:-} \
		"${image}" -c "${args[@]}" || runrc=${?}

	for mp in \
		${mirrormountpointsro[@]+"${mirrormountpointsro[@]}"} \
		${mirrormountpoints[@]+"${mirrormountpoints[@]}"} \
		${mountpointsro[@]+"${!mountpointsro[@]}"} \
		${mountpoints[@]+"${!mountpoints[@]}"}
	do
		[ -n "${mp:-}" ] || continue
		files+=( "${mp}" )
	done
	for mp in ${mountpointsro[@]+"${!mountpointsro[@]}"}; do
		[ -n "${mp:-}" ] || continue
		mp="${mountpointsro[${mp}]}" || continue
		files+=( "${cwd}/${base_dir:+${base_dir}}${mp}" )
	done
	for mp in ${mountpoints[@]+"${!mountpoints[@]}"}; do
		[ -n "${mp:-}" ] || continue
		mp="${mountpoints[${mp}]}" || continue
		files+=( "${cwd}/${base_dir:+${base_dir}}${mp}" )
	done
	for mp in "${files[@]}"; do
		src="$( readlink -e "${mp}" )"
		if [ -n "${src:-}" ]; then
			if [[ -f "${src}" && "$( stat -c '%s %u %a' "${src}" )" == '0 0 700' ]]; then
				warn "Artefact '${src}' detected - removing"
				rm -f "${src}"
			fi
		fi
	done

	# shellcheck disable=SC2086
	return ${runrc}
} # docker_run

docker_trap() {
	trap '' INT
	podman ${@+"${@}"}
	trap - INT
} # docker-trap

if command -v podman >/dev/null 2>&1; then
	docker='podman'
	docker_readonly='ro=true'
	#extra_build_args='--format docker'
fi

rm=''

docker_setup
docker_parse ${@+"${@}"}

image="${image:-${IMAGE}}"
# shellcheck disable=SC2001 # POSIX sh compatibility
name="${name:-$( echo "${image}" | sed 's|[:/]|_|g' )-inspect}"

if [ -n "${rm:-}" ]; then
	docker_trap rm --volumes "${name}" 2>/dev/null || :
fi

rc=0

output >&2 "Launching container '${name}' from image '${image}' ..."

#set -o xtrace
docker_run || rc=${?}

#if [ -n "${rm:-}" ]; then
#	docker_trap rm --volumes "${name}"
#fi

exit ${rc}

# vi: set syntax=sh:
