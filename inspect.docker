#! /usr/bin/env bash

# Tiny
#: "${PODMAN_MEMORY_RESERVATION:=256m}"
#: "${PODMAN_MEMORY_LIMIT:=512m}"
#: "${PODMAN_SWAP_LIMIT:=1g}"
# Small
#: "${PODMAN_MEMORY_RESERVATION:=512m}"
#: "${PODMAN_MEMORY_LIMIT:=1g}"
#: "${PODMAN_SWAP_LIMIT:=2g}"
# Medium
#: "${PODMAN_MEMORY_RESERVATION:=1g}"
#: "${PODMAN_MEMORY_LIMIT:=2g}"
#: "${PODMAN_SWAP_LIMIT:=4g}"
# Large
: "${PODMAN_MEMORY_RESERVATION:=2g}"
: "${PODMAN_MEMORY_LIMIT:=4g}"
: "${PODMAN_SWAP_LIMIT:=8g}"
# Extra-Large
#: "${PODMAN_MEMORY_RESERVATION:=4g}"
#: "${PODMAN_MEMORY_LIMIT:=8g}"
#: "${PODMAN_SWAP_LIMIT:=16g}"

#debug="${DEBUG:-}"
trace="${TRACE:-}"

set -eu

[ -n "${trace:-}" ] && set -o xtrace

cd "$( dirname "$( readlink -e "${0}" )" )" || exit 1

build_name=''

# shellcheck disable=SC1091
[ ! -s common/vars.sh ] || . common/vars.sh

IMAGE="${build_name}:latest"
# shellcheck disable=SC1091
[ -s common/run.sh ] && . common/run.sh >/dev/null

# Provide a '--name' to prevent the container being removed on exit.

# Useful use-cases:
#for s in $( podman image ls | grep '^localhost.*service' | cut -d'/' -f 2- | sed 's/\s\+/:/g' | cut -d':' -f 1-2 ); do ./inspect.docker --remove --image "${s}" 'ls -d /var/db/pkg/*/*systemd* /var/db/pkg/*/*udev*'; done

if [ -n "${*:-}" ]; then
	if echo " ${*} " | grep -Eq -- ' -(h|-help) '; then
		echo >&2 "Usage: $( basename "${0}" ) --image=<image> [--name=<name>] [--remove] [commands]"
		exit 0
	fi
fi

if (( EUID )); then
	die "Please re-run '$( basename "${0}" )' as user 'root'"
fi

docker_parse() {
	local arg=''

	for arg in "${@}"; do
		if [ "${name}" = '<next>' ]; then
			export name="${arg}"

		elif [ "${image}" = '<next>' ]; then
			export image="${arg}"

		elif echo "${arg}" | grep -Eq -- '^-(n|-name)(=[a-z0-9]+([._-]{1,2}[a-z0-9]+)*)?$'; then
			if echo "${arg}" | grep -Fq -- '=' ; then
				name="$( echo "${arg}" | cut -d'=' -f 2- )"
				export name
			else
				name='<next>'
			fi

		elif echo "${arg}" | grep -Eq -- '^-(i|-image)(=[a-z0-9]+([._-]{1,2}[a-z0-9]+)*)?(:.*)?$'; then
			if echo "${arg}" | grep -Fq -- '=' ; then
				image="$( echo "${arg}" | cut -d'=' -f 2- )"
				export image
			else
				image='<next>'
			fi

		elif echo "${arg}" | grep -Eq -- '^-(r|-rm|-remove)$'; then
			rm=1

		else
			#args="${args:+${args} }${arg}"
			args+=( "${arg}" )
		fi
	done
	if [ "${name}" = '<next>' ]; then
		export name=''
	else
		:
	fi
	if [ "${image}" = '<next>' ]; then
		export image=''
	else
		:
	fi

	unset arg
} # docker_parse

docker_run() {
	local -a mirrormountpoints=()
	local -a mirrormountpointsro=()
	local -a runargs=()
	local -A mountpoints=()
	local -A mountpointsro=()
	local -i skipped=0
	local -i runrc=0
	local mp='' src=''  # cwd=''

	#${arr[@]+"${arr[@]}"}
	(( 0 == ${#args[@]} )) && args=( 'sh' )

	runargs=(
		--init
		--name "${name}"
		--privileged
		#--network slirp4netns
		# Some code such as podman's go code tries to fetch packages from
		# IPv6-addressable hosts...
		--network host
		--pids-limit 1024
		  ${rm:+--rm}
		--ulimit nofile=1024:1024
	)
	# shellcheck disable=SC2206
	runargs+=(
		--entrypoint '/bin/sh'
		  ${ACCEPT_KEYWORDS:+--env ACCEPT_KEYWORDS}
		  ${FEATURES:=--env FEATURES}
		  ${TERM:+--env TERM}
		  ${USE:+--env USE}
		--interactive
		--tty
	)
	if [[ -r /proc/cgroups ]] && grep -q -- '^memory.*1$' /proc/cgroups &&
		[[ -n "${PODMAN_MEMORY_RESERVATION:-}" || -n "${PODMAN_MEMORY_LIMIT}" || -n "${PODMAN_SWAP_LIMIT}" ]]
	then
		runargs+=(
			${PODMAN_MEMORY_RESERVATION:+--memory-reservation ${PODMAN_MEMORY_RESERVATION}}
			${PODMAN_MEMORY_LIMIT:+--memory ${PODMAN_MEMORY_LIMIT}}
			${PODMAN_SWAP_LIMIT:+--memory-swap ${PODMAN_SWAP_LIMIT}}
		)
	fi

	# shellcheck disable=SC2046,SC2207
	mirrormountpointsro=(
		/etc/portage/repos.conf
		$( portageq get_repo_path "${EROOT:-/}" $( portageq get_repos "${EROOT:-/}" ) )
		#/usr/src  # Breaks gentoo-kernel-build package
		#/var/db/repo/container
		#/var/db/repo/gentoo
		#/var/db/repo/srcshelton
		#/var/db/repo/compat
	)
	mirrormountpoints=(
		#/var/cache/portage/dist
		"$( portageq distdir )"
		/var/log/portage
	)
	print "Using architecture '${arch:-${ARCH}}' ..."
	mountpoints["$( portageq pkgdir )"]="/var/cache/portage/pkg/${arch:-${ARCH}}/docker"
	[ -S /var/run/syslog-ng/log ] && mountpoints['/var/run/syslog-ng/log']='/dev/log'

	cwd="$( dirname "$( readlink -e "${BASH_SOURCE[$(( ${#BASH_SOURCE[@]} - 1 ))]}" )" )"
	print "Volume/mount base directory is '${cwd}'"
	mountpointsro["${cwd}/gentoo-base/etc/portage/package.accept_keywords"]='/etc/portage/package.accept_keywords'
	mountpointsro["${cwd}/gentoo-base/etc/portage/package.license"]='/etc/portage/package.license'
	mountpointsro["${cwd}/gentoo-base/etc/portage/package.use.build"]='/etc/portage/package.use'

	for mp in ${mirrormountpointsro[@]+"${mirrormountpointsro[@]}"}; do
		[ -n "${mp:-}" ] || continue
		src="$( readlink -e "${mp}" )"
		if [ -z "${src:-}" ]; then
			warn "Skipping mountpoint '${mp}'"
			: $(( skipped = skipped + 1 ))
			continue
		fi
		runargs+=( --mount "type=bind,source=${mp},destination=${mp}${docker_readonly:+,${docker_readonly}}" )
	done
	for mp in ${mirrormountpoints[@]+"${mirrormountpoints[@]}"}; do
		[ -n "${mp:-}" ] || continue
		src="$( readlink -e "${mp}" )"
		if [ -z "${src:-}" ]; then
			warn "Skipping mountpoint '${mp}'"
			: $(( skipped = skipped + 1 ))
			continue
		fi
		runargs+=( --mount "type=bind,source=${mp},destination=${mp}" )
	done
	for mp in ${mountpointsro[@]+"${!mountpointsro[@]}"}; do
		[ -n "${mp:-}" ] || continue
		src="$( readlink -e "${mp}" )"
		if [ -z "${src:-}" ]; then
			warn "Skipping mountpoint '${mp}' -> '${mountpointsro[${mp}]}'"
			: $(( skipped = skipped + 1 ))
			continue
		fi
		runargs+=( --mount "type=bind,source=${src},destination=${mountpointsro[${mp}]}${docker_readonly:+,${docker_readonly}}" )
	done
	for mp in ${mountpoints[@]+"${!mountpoints[@]}"}; do
		[ -n "${mp:-}" ] || continue
		src="$( readlink -e "${mp}" )"
		if [ -z "${src:-}" ]; then
			warn "Skipping mountpoint '${mp}' -> '${mountpoints[${mp}]}'"
			: $(( skipped = skipped + 1 ))
			continue
		fi
		runargs+=( --mount "type=bind,source=${src},destination=${mountpoints[${mp}]}" )
	done

	if [ $(( skipped )) -eq 1 ]; then
		warn "${skipped} mount-points not connected to container"
		sleep 5
	fi

	unset src mp

	# shellcheck disable=SC2086
	$docker run \
			"${runargs[@]}" \
			${DOCKER_EXTRA_MOUNTS:-} \
			${DOCKER_VOLUMES:-} \
		"${image}" -c "${args[@]}" || runrc=${?}

	return ${runrc}
} # docker_run

docker_trap() {
	trap '' INT
	podman ${@+"${@}"}
	trap - INT
} # docker-trap

if command -v podman >/dev/null 2>&1; then
	docker='podman'
	docker_readonly='ro=true'
	#extra_build_args='--format docker'
fi

rm=''

docker_setup
docker_parse ${@+"${@}"}

image="${image:-${IMAGE}}"
# shellcheck disable=SC2001 # POSIX sh compatibility
name="${name:-$( echo "${image}" | sed 's|[:/]|_|g' )-inspect}"

if [ -n "${rm:-}" ]; then
	docker_trap rm --volumes "${name}" 2>/dev/null || :
fi

rc=0

echo >&2 "Launching container '${name}' from image '${image}' ..."

#set -o xtrace
docker_run || rc=${?}

#if [ -n "${rm:-}" ]; then
#	docker_trap rm --volumes "${name}"
#fi

exit ${rc}

# vi: set syntax=sh:
