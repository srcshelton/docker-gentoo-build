#! /usr/bin/env bash

set -eu
set -o pipefail

# shellcheck disable=SC2034
declare debug="${DEBUG:-}"
declare trace="${TRACE:-}"

# If NO_REPO_MASKS is set in the environment then propagate it here so that we
# are able to inspect a container with no masked repos without further hacking!
export NO_REPO_MASKS

[ -n "${trace:-}" ] && set -o xtrace

cd "$( dirname "$( readlink -e "${0}" )" )" || exit 1

# Set by common/vars.sh
declare build_name=''

# shellcheck disable=SC1091
[ ! -s common/vars.sh ] || . common/vars.sh

export IMAGE="${build_name}:latest"
# shellcheck disable=SC1091
[ -s common/run.sh ] && . common/run.sh >/dev/null

export mount=''

# Provide a '--name' to prevent the container being removed on exit.

# Useful use-cases:
#for s in $(
#	podman image ls |
#		grep '^localhost.*service' |
#		cut -d'/' -f 2- |
#		sed 's/\s\+/:/g' |
#		cut -d':' -f 1-2
#); do
#	./inspect.docker --remove --image "${s}" \
#		'ls -d /var/db/pkg/*/*systemd* /var/db/pkg/*/*udev*'
#done

if [ -n "${*:-}" ]; then
	if echo " ${*} " | grep -Eq -- ' -(h|-help) '; then
		output >&2 "Usage: $( basename "${0}" ) [--image=<image>]" \
			"[--name=<name>] [--remove] [--mount=<...>] [commands]"
		exit 0
	fi
fi

# Support 'core' user for podman+machine Fedora default user...
if [[ "$( uname -s )" == 'Darwin' ]]; then
	if (( EUID )) && [[ "$( id -nu )" == 'core' ]]; then
		die "Please re-run '$( basename "${0}" )' as user 'root'"
	fi
fi

declare -a args=() container_args=()

_docker_parse() {
	local arg=''

	for arg in "${@:-}"; do
		if [ "${name}" = '<next>' ]; then
			export name="${arg}"

		elif [ "${image}" = '<next>' ]; then
			export image="${arg}"

		elif [ "${mount}" = '<next>' ]; then
			export mount="${arg}"

		elif echo "${arg}" | grep -Eq -- '^-(n|-name)(=[a-z0-9]+([._-]{1,2}[a-z0-9]+)*)?$'; then
			if echo "${arg}" | grep -Fq -- '=' ; then
				name="$( echo "${arg}" | cut -d'=' -f 2- )"
				print "Setting container name to '${name}' in $( basename -- "${0#-}" )"
				export name
			else
				name='<next>'
			fi

		elif echo "${arg}" | grep -Eq -- '^-(i|-image)(=[a-z0-9]+([._-]{1,2}[a-z0-9]+)*)?(:.*)?$'; then
			if echo "${arg}" | grep -Fq -- '=' ; then
				image="$( echo "${arg}" | cut -d'=' -f 2- )"
				export image
			else
				image='<next>'
			fi

		elif echo "${arg}" | grep -Eq -- '^-(m|-mount)(=)?(:.*)?$'; then
			if echo "${arg}" | grep -Fq -- '=' ; then
				mount="$( echo "${arg}" | cut -d'=' -f 2- )"
				export mount
			else
				mount='<next>'
			fi

		elif echo "${arg}" | grep -Eq -- '^-(r|-rm|-remove)$'; then
			rm=1

		else
			#args="${args:+${args} }${arg}"
			args+=( "${arg}" )
		fi
	done
	if [ "${name}" = '<next>' ]; then
		export name=''
	fi
	if [ "${image}" = '<next>' ]; then
		export image=''
	fi
	if [ "${mount}" = '<next>' ]; then
		export mount=''
	fi

	for arg in "${args[@]:-}"; do
		container_args+=( "${arg}" )
	done

	unset arg
}  # _docker_parse

# shellcheck disable=SC2120
docker_run() {
	local -a mirrormountpoints=()
	local -a mirrormountpointsro=()
	local -a runargs=()
	local -a files=()
	local -A mountpoints=()
	local -A mountpointsro=()
	local -i skipped=0
	local -i runrc=0
	local mp='' src=''  # cwd=''
	local default_repo_path='' default_distdir_path='' default_pkgdir_path=''

	#${arr[@]+"${arr[@]}"}
	(( 0 == ${#args[@]} )) && args=( 'sh' )

	# shellcheck disable=SC2207
	runargs=(
		$(
			# shellcheck disable=SC2015
			if
				[[ "$( uname -s )" != 'Darwin' ]] &&
					(( $( nproc ) > 1 )) &&
					$docker info 2>&1 |
						grep -q -- 'cpuset'
			then
				echo "--cpuset-cpus 1-$(( $( nproc ) - 1 ))"
			fi
		)
		--init
		--name "${name}"
		--privileged
		#--network slirp4netns
		# Some code such as podman's go code tries to fetch packages from
		# IPv6-addressable hosts...
		--network host
		--pids-limit 1024
		  ${rm:+--rm}
		--ulimit nofile=1024:1024
	)
	# shellcheck disable=SC2206
	runargs+=(
		--entrypoint '/bin/sh'
		  ${ACCEPT_KEYWORDS:+--env ACCEPT_KEYWORDS}
		  ${FEATURES:=--env FEATURES}
		  ${TERM:+--env TERM}
		  ${USE:+--env USE}
		--interactive
		--tty
		  ${DOCKER_EXTRA_MOUNTS:-}
		  ${DOCKER_VOLUMES:-}
	)
	if [[ -r /proc/cgroups ]] && grep -q -- '^memory.*1$' /proc/cgroups &&
		[[ -n "${PODMAN_MEMORY_RESERVATION:-}" || -n "${PODMAN_MEMORY_LIMIT}" || -n "${PODMAN_SWAP_LIMIT}" ]]
	then
		runargs+=(
			${PODMAN_MEMORY_RESERVATION:+--memory-reservation ${PODMAN_MEMORY_RESERVATION}}
			${PODMAN_MEMORY_LIMIT:+--memory ${PODMAN_MEMORY_LIMIT}}
			${PODMAN_SWAP_LIMIT:+--memory-swap ${PODMAN_SWAP_LIMIT}}
		)
	fi

	if ! type -pf portageq >/dev/null 2>&1; then
		default_repo_path='/var/db/repos/gentoo /var/db/repos/srcshelton'
		default_distdir_path='/var/cache/portage/dist'
		default_pkgdir_path='/var/cache/portage/pkg'
		if [ ! -d /var/db/repos/gentoo ] && [ -d /var/db/repo/gentoo ]; then
			default_repo_path='/var/db/repo/gentoo /var/db/repo/srcshelton'
		fi
	fi
	if [ -n "${PKGDIR_OVERRIDE:-}" ]; then
		default_pkgdir_path="${PKGDIR_OVERRIDE}"
	fi

	# shellcheck disable=SC2046,SC2206,SC2207
	mirrormountpointsro=(
		# We need write access to be able to update eclasses...
		#/etc/portage/repos.conf
		${default_repo_path:-$( portageq get_repo_path "${EROOT:-/}" $( portageq get_repos "${EROOT:-/}" ) )}
		#/usr/src  # Breaks gentoo-kernel-build package
		#/var/db/repo/container
		#/var/db/repo/gentoo
		#/var/db/repo/srcshelton
		#/var/db/repo/compat
	)
	mirrormountpoints=(
		#/var/cache/portage/dist
		"${default_distdir_path:-$( portageq distdir )}"
		'/var/log/portage'
	)

	#ENV PKGDIR="${PKGCACHE:-/var/cache/portage/pkg}/${ARCH:-amd64}/${PKGHOST:-docker}"
	#local PKGCACHE="${PKGCACHE:=/var/cache/portage/pkg}"
	#local PKGHOST="${PKGHOST:=docker}"
	local PKGDIR="${PKGDIR:=${default_pkgdir_path:-$( portageq pkgdir )}}"

	# Allow use of 'ARCH' variable as an override...
	print "Using architecture '${ARCH:-${arch}}' ..."
	mountpoints["${PKGDIR}"]="/var/cache/portage/pkg/${ARCH:-${arch}}/docker"
	mountpoints['/etc/portage/repos.conf']='/etc/portage/repos.conf.host'
	[ -S /var/run/syslog-ng/log ] && mountpoints['/var/run/syslog-ng/log']='/dev/log'

	cwd="$( dirname "$( readlink -e "${BASH_SOURCE[$(( ${#BASH_SOURCE[@]} - 1 ))]}" )" )"
	print "Volume/mount base directory is '${cwd}'"
	mountpointsro["${cwd}/${base_dir:+"${base_dir}/"}etc/portage/package.accept_keywords"]='/etc/portage/package.accept_keywords'
	if [ -s "${cwd}/${base_dir:+"${base_dir}/"}etc/portage/package.accept_keywords.${ARCH:-${arch}}" ]; then
		mountpointsro["${cwd}/${base_dir:+"${base_dir}/"}etc/portage/package.accept_keywords.${ARCH:-${arch}}"]="/etc/portage/package.accept_keywords/${ARCH:-${arch}}"
	fi
	mountpointsro["${cwd}/${base_dir:+"${base_dir}/"}etc/portage/package.license"]='/etc/portage/package.license'
	mountpointsro["${cwd}/${base_dir:+"${base_dir}/"}etc/portage/package.use.build"]='/etc/portage/package.use'

	for mp in ${mirrormountpointsro[@]+"${mirrormountpointsro[@]}"}; do
		[ -n "${mp:-}" ] || continue
		src="$( readlink -e "${mp}" )" || die "readlink() on mirrored read-only mountpoint '${mp}' failed: ${?}"
		if [ -z "${src:-}" ]; then
			warn "Skipping mountpoint '${mp}'"
			: $(( skipped = skipped + 1 ))
			continue
		fi
		runargs+=( --mount "type=bind,source=${src},destination=${mp}${docker_readonly:+,${docker_readonly}}" )
	done
	for mp in ${mirrormountpoints[@]+"${mirrormountpoints[@]}"}; do
		[ -n "${mp:-}" ] || continue
		src="$( readlink -e "${mp}" )" || die "readlink() on mirrored mountpoint '${mp}' failed: ${?}"
		if [ -z "${src:-}" ]; then
			warn "Skipping mountpoint '${mp}'"
			: $(( skipped = skipped + 1 ))
			continue
		fi
		runargs+=( --mount "type=bind,source=${src},destination=${mp}" )
	done
	for mp in ${mountpointsro[@]+"${!mountpointsro[@]}"}; do
		[ -n "${mp:-}" ] || continue
		src="$( readlink -e "${mp}" )" || die "readlink() on read-only mountpoint '${mp}' failed: ${?}"
		if [ -z "${src:-}" ]; then
			warn "Skipping mountpoint '${mp}' -> '${mountpointsro[${mp}]}'"
			: $(( skipped = skipped + 1 ))
			continue
		fi
		runargs+=( --mount "type=bind,source=${src},destination=${mountpointsro[${mp}]}${docker_readonly:+,${docker_readonly}}" )
	done
	for mp in ${mountpoints[@]+"${!mountpoints[@]}"}; do
		[ -n "${mp:-}" ] || continue
		src="$( readlink -e "${mp}" )" || die "readlink() on mountpoint '${mp}' failed (do you need to set 'PKGDIR'?): ${?}"
		if [ -z "${src:-}" ]; then
			warn "Skipping mountpoint '${mp}' -> '${mountpoints[${mp}]}'"
			: $(( skipped = skipped + 1 ))
			continue
		fi
		runargs+=( --mount "type=bind,source=${src},destination=${mountpoints[${mp}]}" )
	done

	if [ $(( skipped )) -ge 1 ]; then
		warn "${skipped} mount-points not connected to container"
		sleep 5
	fi

	runargs+=( --mount 'type=tmpfs,destination=/run,ro=false,tmpfs-size=10M,tmpfs-mode=0755' )

	if [[ -n "${mount:-}" ]]; then
		print "Adding command line mount option '--mount ${mount}' ..."
		runargs+=( --mount "${mount}" )
	fi

	unset src mp

	if [ -n "${DOCKER_VERBOSE:-}" ]; then
		output
		[ -n "${DOCKER_VARS:-}" ] && output "VERBOSE: DOCKER_VARS is '${DOCKER_VARS}'"
		local arg='' next=''
		for arg in "${runargs[@]}"; do
			case "${next}" in
				mount)
					arg="$(
						sed -r \
								-e 's/^type=/type: /' \
								-e 's/,(src|source)=/\tsource: /' \
								-e 's/,(dst|destination)=/\tdestination: /' \
								-e 's/, ro=true$/\tRO/' \
							<<<"${arg}"
					)"
					output "VERBOSE: Mount point '${arg}'"
					;;
				volume)
					output "VERBOSE: Volume '${arg}'"
					;;
			esac
			if [[ "${arg}" =~ ^--(mount|volume)$ ]]; then
				next="${arg#--}"
			else
				next=''
			fi
		done | column -t -s $'\t'
		unset next arg
		output
	fi

	(
		if (( debug )); then
			local arg=''
			print "Starting container with command '$docker container run \\"
			for arg in "${runargs[@]}"; do
				print "        ${arg} \\"
			done
			print "    ${image}"
			for arg in "${@}"; do
				print "        ${arg} \\"
			done
			print "'"
			unset arg
			if touch inspect.docker.debug.log; then
				echo >inspect.docker.debug.log <<-EOF
					#! /bin/sh

					set -eux

				EOF
				printf >>inspect.docker.debug.log '%s container run \\\n' "${docker}"
				for arg in "${runargs[@]}"; do
					printf >>inspect.docker.debug.log '        %s \\\n' "${arg}"
				done
				unset arg
				printf >>inspect.docker.debug.log '    %s \\\n' "${image}"
				# Start at $1 as $0 is the command itself...
				local -i i=1
				for (( ; i < ${#} ; i++ )); do
					printf >>inspect.docker.debug.log '        %s \\\n' "${!i:-}"
				done
				# At this point i == ${#}...
				printf >>inspect.docker.debug.log '        %s\n' "${!i:-}"
				unset i
			fi
		fi
		# shellcheck disable=SC2086
		$docker \
				${DOCKER_VARS:-} \
			container run \
				"${runargs[@]}" \
			"${image}" -c "${args[@]}"
	)
	runrc=${?}

	for mp in \
		${mirrormountpointsro[@]+"${mirrormountpointsro[@]}"} \
		${mirrormountpoints[@]+"${mirrormountpoints[@]}"} \
		${mountpointsro[@]+"${!mountpointsro[@]}"} \
		${mountpoints[@]+"${!mountpoints[@]}"}
	do
		[ -n "${mp:-}" ] || continue
		files+=( "${mp}" )
	done
	for mp in ${mountpointsro[@]+"${!mountpointsro[@]}"}; do
		[ -n "${mp:-}" ] || continue
		mp="${mountpointsro[${mp}]}" || continue
		files+=( "${cwd}/${base_dir:+"${base_dir}"}${mp}" )
	done
	for mp in ${mountpoints[@]+"${!mountpoints[@]}"}; do
		[ -n "${mp:-}" ] || continue
		mp="${mountpoints[${mp}]}" || continue
		files+=( "${cwd}/${base_dir:+"${base_dir}"}${mp}" )
	done
	files+=( /etc/portage/package.accept_keywords/arm64 )
	for mp in "${files[@]}"; do
		src="$( readlink -e "${mp}" )"
		if [ -n "${src:-}" ]; then
			if [[ -f "${src}" && "$( stat -c '%s %u %a' "${src}" )" == '0 0 700' ]]; then
				warn "Artefact '${src}' detected - removing"
				rm -f "${src}"
			fi
		fi
	done
	unset files

	for oom in oom "${cwd}/${base_dir:+"${base_dir}/"}oom"; do
		src="$( readlink -e "${oom}" )"
		if [ -n "${src:-}" ]; then
			if [[ -f "${src}" && "$( stat -c '%s %u %a' "${src}" )" == '0 0 644' ]]; then
				warn "Artefact '${src}' detected - removing"
				rm -f "${src}"
			fi
		fi
	done

	# shellcheck disable=SC2086
	return ${runrc}
}  # docker_run

docker_trap() {
	trap '' INT
	podman ${@+"${@}"}
	trap - INT
}  # docker-trap

main() {
	local arg=''
	local -a main_args=()

	if [[ -n "${*:-}" ]]; then
		for arg in "${@:-}"; do
			case "${arg:-}" in
				--memory-reservation=*)
					PODMAN_MEMORY_RESERVATION="${arg#*=}"
					;;
				--memory-limit=*)
					PODMAN_MEMORY_LIMIT="${arg#*=}"
					;;
				--swap-limit=*)
					PODMAN_SWAP_LIMIT="${arg#*=}"
					;;
				*)
					main_args+=( "${arg}" )
					;;
			esac
		done
		set -- "${main_args[@]:-}"
		#print "args: (${#}) '${*:-}'"
	fi
	unset main_args arg

	if [[ -z "${NO_MEMORY_LIMITS:-}" ]]; then
		# Tiny
		#: "${PODMAN_MEMORY_RESERVATION:=256m}"
		#: "${PODMAN_MEMORY_LIMIT:=512m}"
		#: "${PODMAN_SWAP_LIMIT:=1g}"
		# Small
		#: "${PODMAN_MEMORY_RESERVATION:=512m}"
		#: "${PODMAN_MEMORY_LIMIT:=1g}"
		#: "${PODMAN_SWAP_LIMIT:=2g}"
		# Medium
		#: "${PODMAN_MEMORY_RESERVATION:=1g}"
		#: "${PODMAN_MEMORY_LIMIT:=2g}"
		#: "${PODMAN_SWAP_LIMIT:=4g}"
		# Large
		#: "${PODMAN_MEMORY_RESERVATION:=2g}"
		#: "${PODMAN_MEMORY_LIMIT:=4g}"
		#: "${PODMAN_SWAP_LIMIT:=8g}"
		# Extra-Large
		#: "${PODMAN_MEMORY_RESERVATION:=4g}"
		#: "${PODMAN_MEMORY_LIMIT:=8g}"
		#: "${PODMAN_SWAP_LIMIT:=16g}"
		#
		#: "${PODMAN_MEMORY_RESERVATION:="4g"}"
		#: "${PODMAN_MEMORY_LIMIT:="6g"}"
		#
		# See comments in common/vars.sh...
		#
		: "${PODMAN_MEMORY_RESERVATION:="2g"}"
		: "${PODMAN_MEMORY_LIMIT:="6g"}"
		: "${PODMAN_SWAP_LIMIT:="${PODMAN_MEMORY_LIMIT}"}"

		local -i swp=$(( ( $( grep -m 1 'SwapTotal:' /proc/meminfo | awk '{ print $2 }' ) + 16 ) / 1024 / 1024 ))
		local -i ram=$(( $( grep -m 1 'MemTotal:' /proc/meminfo | awk '{ print $2 }' ) / 1024 / 1024 ))
		local -i changed=0
		if (( ram < ${PODMAN_MEMORY_LIMIT%g} )) || (( ( ram + swp ) < ${PODMAN_SWAP_LIMIT%g} )); then
			echo >&2 "INFO:  Host resources (rounded down to nearest 1GiB):"
			echo >&2 "         RAM:        ${ram}G"
			echo >&2 "         Swap:       ${swp}G"
			echo >&2 "INFO:  Original memory limits:"
			echo >&2 "         Soft limit: ${PODMAN_MEMORY_RESERVATION%g}G"
			echo >&2 "         Hard limit: ${PODMAN_MEMORY_LIMIT%g}G"
			echo >&2 "         RAM + Swap: ${PODMAN_SWAP_LIMIT%g}G"
		fi
		if (( ram < ${PODMAN_MEMORY_LIMIT%g} )); then
			PODMAN_MEMORY_RESERVATION="$(( ram - 1 ))g"
			PODMAN_MEMORY_LIMIT="$(( ram ))g"
			#PODMAN_SWAP_LIMIT="$(( ram + swp ))g"
			if (( ram <= 1 )); then
				PODMAN_SWAP_LIMIT="$(( ram * 2 ))g"
			else
				PODMAN_SWAP_LIMIT="$(( ram + $(
					awk -v ram="${ram}" 'BEGIN{ print int( sqrt( ram ) + 0.5 ) }'
				) ))g"
			fi
			changed=1
		fi
		if (( ( ram + swp ) < ${PODMAN_SWAP_LIMIT%g} )); then
			#PODMAN_SWAP_LIMIT="$(( ram + swp ))g"
			if (( ram <= 1 )); then
				PODMAN_SWAP_LIMIT="$(( ram * 2 ))g"
			else
				PODMAN_SWAP_LIMIT="$(( ram + $(
					awk -v ram="${ram}" 'BEGIN{ print int( sqrt( ram ) + 0.5 ) }'
				) ))g"
			fi
			changed=1
		fi
		if (( changed )); then
			echo >&2 "NOTE:  Changed memory limits based on host configuration:"
			echo >&2 "         Soft limit: ${PODMAN_MEMORY_RESERVATION%g}G"
			echo >&2 "         Hard limit: ${PODMAN_MEMORY_LIMIT%g}G"
			echo >&2 "         RAM + Swap: ${PODMAN_SWAP_LIMIT%g}G"
			echo >&2
		fi
		unset changed ram swp
	fi

	declare rm=''

	_docker_setup
	_docker_parse ${@+"${@}"}

	image="${image:-${IMAGE}}"
	# shellcheck disable=SC2001 # POSIX sh compatibility
	name="${name:-$( echo "${image}" | sed 's|[:/]|_|g' )-inspect}"

	if [ -n "${rm:-}" ]; then
		docker_trap rm --volumes "${name}" 2>/dev/null || :
	fi

	local -i rc=0

	output >&2 "Launching container '${name}' from image '${image}' ..."

	#set -o xtrace
	docker_run "${container_args[@]:-}" || rc=${?}

	#if [ -n "${rm:-}" ]; then
	#	docker_trap rm --volumes "${name}"
	#fi

	return ${rc}
}  # main

main "${@:-}"
exit ${?}

# vi: set colorcolumn=80 foldmarker=()\ {,}\ \ #\  foldmethod=marker syntax=bash:
